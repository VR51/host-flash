#!/bin/bash
# set -euo pipefail
# set -x
IFS=$'\n\t'
###
#
# Host Flash™ 3.1.7
#
# Downloads hosts file rules from various sources.
# Installs hosts file rules into /etc/hosts
# Integrates Host Flash™ hosts file rules with rules that already exist in /etc/hosts
#
# For OS: Linux (Debian)
# Tested With: Ubuntu flavours
#
# Lead Author: Lee Hodson<https://github.com/vr51//>
# Contributor: skeletonkey<https://github.com/skeletonkey/>
# Donate: https://paypal.me/vr51
# Website: https://host-flash.com<https://host-flash.com>
# This Release: 10th May 2020
# First Written: 18th Oct. 2015
# First Release: 2nd Nov. 2015
#
# Copyright Host Flash™ https://host-flash.com<https://host-flash.com>
# License: GPL3
#
# Programmer: Lee Hodson<journalxtra.com>, VR51<vr51.com>
#
# Use of this program is at your own risk
#
# INSTALLS OR UPDATES
#
# Use Host Flash™ to block access to websites (hosts), ad servers, malicious websites and time wasting websites.
# Use Host Flash™ to manage your hosts file
#
# TO RUN:
#
# Ensure the script is executable:
#
#  Right-click > properties > Executable
#
#  OR
#
#  chmod u+x hostflash
#
# Launch by clicking the script file or by typing `bash hostflash` at the command line.
#
# Host Flash™ will attempt to preserve existing host rules.
#
#
###

##
#
# TO DO / DEV NOTES
#		YOU. Yes, you. Ignore the dev notes. These are for me to read ;)
#		Please feel free to work through this list if you wish to do so.
#
##
# versions: add deb installer
#
#  En/disable Automatic list update
#  En/disable Automatic script update
#
# CLI: disable HF, enable HF, add rule, remove rule, update lists, set options
#
#
# List Build Options
#  Build pure list. No whitelisting
#   Check whitelists (extracted, found, not found) # To be integrated from standalone file.
#    Rebuild whitelists after check
#  Build filtered list. Whitelisting done
#   Install after build
#   Do not install after build
# Compact local whitelists and local blacklists (all lower, sort -u)
# View/Edit local lists (nano, pico, cat)
#
#
# Switchlist
#  Temporarily disable and enable whitelist hosts
# Options
#  Check .hfremoved list # Script written and tested ready for insertion
#   Move items from .hfremoved to post processing blacklist
#   Move items from .hfremoved to Switch List
#
# Move even more actions into functions.
# Tidy up
# Add input checking
# Refine/add messages
#
# Improve menu system
#  What do you want to do? Manage Lists, Update hosts, Manage Custom Files, See Info
#   Do it
#  Clearer messages
#
# Summary info on main screen / maybe footer for all screens
#  Add more useful info
#  Include link to host-flash.com
#
#  View all HF configs
#
#  Info about each list
#   Last update time
#
# Add last 7 updates log
#  ${log#[time]}
#  ${log#[size]}
#  ${log#[lines]}
#
# Add hosts file backup option
#
# Go through functions to state the output format
#
###

##
# NOTES
#
# Build Process
#
#  The host file work is done in $HOME/src/hostflash/tmp. This eventually builds hosts.txt
#  The final build of hosts.txt is moved to $HOME/src/hostflash/
#  __enable looks for $HOME/src/hostflash/hosts.txt which it moves to /etc/hosts
#
# Whitelist Processing
#
#  Whitelist wild is processed twice:
#   As a normal whitelist
#   As a wild whitelist
#  A period is added before the first character of the host name
#
##

##
#
# CONFIGS - should be no reason to manually change these
#
# Any of these can be overruled by adding each variable along with its new value into $HOME/.config/hostflash/.hfrc
#
##

# Do not Use trailing slashes in URLs, URIs or directory paths

package='Host Flash™' # Name of software installed by this installer
version='3.1.7 - 10th May 2020'
debug='0'

# Clear arrays

unset app conf dir file log list message rem menu select mode essentialpackages credits flush listc listcc listsc

# Declare arrays and types

declare -A app conf dir file list log message rem

declare -a menu # Menu options are set within __menu_main()
declare -a select # Menu options count
declare -a mode # Used for notices
declare -a essentialpackages # Packages to install to help the build process
declare -a credits # Hosts file credits
declare -a flush # DNS cache flush commands
declare -i listc listcc listsc # For list repository counts

# Remote Hosts

rem[gith]='https://github.com/VR51/host-flash' # Github home URL for this package.
rem[gitp]='https://github.com/VR51/host-flash.git' # Software source package git address
rem[tld]='https://data.iana.org/TLD/tlds-alpha-by-domain.txt' # Official list of valid TLDs

# Directories
#  These are created by dir[@] dump. Be careful when adding directories to this list

dir[src]="$HOME/src/hostflash" # Directory where the source code will be stored locally
dir[tmp]="${dir[src]}/tmp" # Directory where temporary files will be stored locally
dir[docs]="${dir[src]}/DOC" # Location of program documents. # To be written
dir[conf]="$HOME/.config/hostflash" # Location of custom configuration files.

# Files

file[hosts]=''
# System hosts file location. Where it is copied from and where it is installed to.
# file[hosts]='/etc/hosts' # Location of system hosts file in Unix, Unix-like and POSIX systems.
# file[hosts]='/private/etc/hosts' # iOS, Apple Mac
# file[hosts]='/system/etc/hosts' # Android
# file[hosts]='%SystemRoot%\System32\drivers\etc\hosts' # Windows NT, 2000, XP,[5] 2003, Vista, 2008, 7, 2012, 8, 10

# Custom Hosts File location
# file[hosts]='/enter/path/to/file/called/hosts' # Add the path to your system's hosts file then uncomment (remove the #) and save to activate.

function __clear() {
	if [ $debug == '0' ]; then
		clear
	fi
}

__clear

if test ! "${file[hosts]}"; then
	if test -f "/system/etc/hosts"; then
		file[hosts]='/system/etc/hosts'
	elif test -f "/private/etc/hosts"; then
		file[hosts]='/private/etc/hosts'
	elif test -f "/etc/hosts"; then
		file[hosts]='/etc/hosts'
	else
		echo "Unable to detect the location of this system's hosts file."
		echo "Please edit the hostflash program at around line 189 to set a custom value for ${bold}file[hosts]${normal} to point to your system's hosts file."
		echo "Remember to uncomment the line edited and visit ${bold}${rem[gith]}${normal} if you want us to add your host file's location to automatic detection list."
		echo "Press any key to exit $package"
		read a
		exit 1
	fi
fi

# HF Config Files
#  These are created by file[@] dump. Be careful when adding files to this list

file[conf]="${dir[conf]}/.hfrc" # Location of user's custom settings for Host Flash™.
file[confwl]="${dir[conf]}/.hfwlrc" # Location of the user's custom whitelist.
file[confwlw]="${dir[conf]}/.hfwlwrc" # Location of the user's custom whitelist-wild.
file[confbl]="${dir[conf]}/.hfblrc" # Location of the user's custom blacklist.
file[confcl]="${dir[conf]}/.hfclrc" # Location of the user's custom hosts lists.
file[confr]="${dir[conf]}/.hfremoved" # Hosts removed from hosts list during hosts build/update.
file[conftld]="${dir[conf]}/.hftld" # Location of valid TLD list.
file[debug]="${dir[conf]}/.debug.txt" # Location of debug logging file.

# to be used in a later version
file[confpost]="${dir[conf]}/.hfpost" # Location of the post processing blacklist (block hosts that are wild needlessly whitelisted)
file[confsl]="${dir[conf]}/.hfslrc" # Location of the user's hosts switch list.
file[log]="${dir[conf]}/.log" # Location of the log file.

# App Launcher Settings
# These are specific to the application/task manager installer (yet to be implemented)

app[icon]="${dir[src]}/data" # Directory where the application icon will be located.
app[bin]='/usr/bin' # Binary installation path. Where should the compiled binary be installed to? Exact path. # Not required for this installer.
app[icon]="hostflash.svg" # Icon name
app[type]='Application' # 
app[cats]='Utilities' # Application launcher categories
app[binary]="hostflash" # Name of the binary file that is this program.

# Detected settings

user=$(whoami) # Current User
group=$(id -g -n $user) # Current user's primary group


###
#
# DECLARE LIST ARRAYS
# 
###

# Declare custom list associative arrays. If they are not declared we cannot use them.

# Count Lists
listc=$(grep -E '\[status[[:digit:]]+]=' "$0" | wc -l) # Count lists in hostflash script
if test $(grep -En '\[status[[:digit:]]+]=' "${file[confcl]}")
then
	listcc=$(grep -E '\[status[[:digit:]]+]=' "${file[confcl]}" | wc -l) # Count custom lists in .hfclrc
else
	listcc=0
fi
let listsc=listc+listcc


##
#
# LISTS
#
#
# These are...
#
# list[status]='Enabled / Disabled' # + or - for TRUE or FALSE
# list[info]='List Domain' # The name of the list
# list[src]='Download URL' # From where the package will be retrieved
# list[file]='Download Package' # Name of package retrieved
# list[target]='Package Target' # Name of usable file in a retrieved zip package / Name of file created on retrieval if FLAG is raw
# list[flag]='package Type' # direct (the URL leads to the file), raw (URL + File name are used to get the file), unzip (URL + file name, unzip is used), p7zip (URL + File name, p7zip is used).
# list[ip]='0' # 0 or 1 for false or true. Add loopback IP address to downloaded list. This is required of a hosts list consists of domain names with no IP prefix. Not required for whitelists, in fact should never be set to '1' for whitelists.
#
# Changes to list[status] are stored in .hfrc
# Custom lists will be added to .hfclrc
#		Framework in place: conf etc... Needs menu section to be added.
#
##

# TO DO: Change to list[NUM TYPE]
# https://hosts-file.net/?s=Download <-- DEAD. This is now a Malwarebytes browser addon.
# Files from here now mirrored and updated at https://github.com/fredprod/host-file.net-backup
# & https://github.com/blackskye-sx/host-file.net-backup
list[status1]='+'
list[info1]='hosts-file.net - Ad Servers (Liberal)'
list[src1]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file1]='ad_servers.txt'
list[target1]='ad_servers.txt'
list[flag1]='raw'
list[ip1]='0'

list[status2]='+'
list[info2]='hosts-file.net - EMD (Liberal)'
list[src2]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file2]='emd.txt'
list[target2]='emd.txt'
list[flag2]='raw'
list[ip2]='0'

list[status3]='+'
list[info3]='hosts-file.net - EXP (Liberal)'
list[src3]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file3]='exp.txt'
list[target3]='exp.txt'
list[flag3]='raw'
list[ip3]='0'

list[status4]='+'
list[info4]='hosts-file.net - FSA (Liberal)'
list[src4]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file4]='fsa.txt'
list[target4]='fsa.txt'
list[flag4]='raw'
list[ip4]='0'

list[status5]='+'
list[info5]='hosts-file.net - GRM (Liberal)'
list[src5]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file5]='grm.txt'
list[target5]='grm.txt'
list[flag5]='raw'
list[ip5]='0'

list[status6]='+'
list[info6]='hosts-file.net - HFS (Liberal)'
list[src6]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file6]='hfs.txt'
list[target6]='hfs.txt'
list[flag6]='raw'
list[ip6]='0'

list[status7]='+'
list[info7]='hosts-file.net - HJK (Liberal)'
list[src7]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file7]='hjk.txt'
list[target7]='hjk.txt'
list[flag7]='raw'
list[ip7]='0'

list[status8]='+'
list[info8]='hosts-file.net - MMT (Liberal)'
list[src8]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file8]='mmt.txt'
list[target8]='mmt.txt'
list[flag8]='raw'
list[ip8]='0'

list[status9]='+'
list[info9]='hosts-file.net - PHA (Liberal)'
list[src9]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file9]='pha.txt'
list[target9]='pha.txt'
list[flag9]='raw'
list[ip9]='0'

list[status10]='+'
list[info10]='hosts-file.net - PSH (Liberal)'
list[src10]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file10]='psh.txt'
list[target10]='psh.txt'
list[flag10]='raw'
list[ip10]='0'

list[status11]='+'
list[info11]='hosts-file.net - PUP (Liberal)'
list[src11]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file11]='pup.txt'
list[target11]='pup.txt'
list[flag11]='raw'
list[ip11]='0'

list[status12]='+'
list[info12]='hosts-file.net - WRZ (Liberal)'
list[src12]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file12]='wrz.txt'
list[target12]='wrz.txt'
list[flag12]='raw'
list[ip12]='0'

list[status13]='+'
list[info13]='mvps.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Big list)'
list[src13]='http://winhelp2002.mvps.org'
list[file13]='hosts.zip'
list[target13]='HOSTS'
list[flag13]='unzip'
list[ip13]='0'

list[status14]='+'
list[info14]='free.fr-Trackers (Moderate: Blocks trackers)'
list[src14]='http://rlwpx.free.fr/WPFF'
list[file14]='htrc.7z'
list[target14]='Hosts.trc'
list[flag14]='p7zip'
list[ip14]='0'

list[status15]='+'
list[info15]='free.fr-Ad-Servers (Moderate: Blocks ad servers)'
list[src15]='http://rlwpx.free.fr/WPFF'
list[file15]='hpub.7z'
list[target15]='Hosts.pub'
list[flag15]='p7zip'
list[ip15]='0'

list[status16]='+'
list[info16]='free.fr-Malware (Moderate: Blocks malware domains)'
list[src16]='http://rlwpx.free.fr/WPFF'
list[file16]='hrsk.7z'
list[target16]='Hosts.rsk'
list[flag16]='p7zip'
list[ip16]='0'

list[status17]='+'
list[info17]='free.fr-Adult (Moderate: Blocks adult domains. Coincidentally blocks forums and some social sites)'
list[src17]='http://rlwpx.free.fr/WPFF'
list[file17]='hsex.7z'
list[target17]='Hosts.sex'
list[flag17]='p7zip'
list[ip17]='0'

list[status18]='+'
list[info18]='free.fr-Misc (Moderate: Blocks miscellaneous domains)'
list[src18]='http://rlwpx.free.fr/WPFF'
list[file18]='hmis.7z'
list[target18]='Hosts.mis'
list[flag18]='p7zip'
list[ip18]='0'

list[status19]='+'
list[info19]='someonewhocares.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Small list)'
list[src19]='http://someonewhocares.org/hosts'
list[file19]='hosts'
list[target19]='hosts.txt'
list[flag19]='raw'
list[ip19]='0'

list[status20]='+'
list[info20]='malwaredomainlist.com (Liberal: Blocks mostly malware. Small list)'
list[src20]='http://www.malwaredomainlist.com/hostslist'
list[file20]='hosts.txt'
list[target20]='hosts.txt'
list[flag20]='raw'
list[ip20]='0'

list[status21]='+'
list[info21]='KADhosts (Liberal: Blocks malware hosts)'
list[src21]='https://raw.githubusercontent.com/azet12/KADhosts/master/KADhosts.txt'
list[file21]='hosts.txt'
list[target21]='hosts.txt'
list[flag21]='direct'
list[ip21]='0'

list[status22]='+'
list[info22]='yoyo.org (Liberal: Blocks adservers)'
list[src22]='https://pgl.yoyo.org/as/serverlist.php?showintro=0;hostformat=hosts'
list[file22]='hosts.txt'
list[target22]='hosts.txt'
list[flag22]='direct'
list[ip22]='0'

list[status23]='+'
list[info23]='Mitchell Krog (Liberal: Blocks spam bot hosts)'
list[src23]='https://raw.githubusercontent.com/mitchellkrogza/Badd-Boyz-Hosts/master/hosts'
list[file23]='hosts.txt'
list[target23]='hosts.txt'
list[flag23]='direct'
list[ip23]='0'

list[status24]='+'
list[info24]='CoinBlockerLists (Liberal: Blocks cryptominers)'
list[src24]='https://zerodot1.gitlab.io/CoinBlockerLists/hosts_browser'
list[file24]='hosts.txt'
list[target24]='hosts.txt'
list[flag24]='direct'
list[ip24]='0'

list[status25]='+'
list[info25]='Lightswitch05 (Liberal: Blocks ads and trackers)'
list[src25]='https://raw.githubusercontent.com/lightswitch05/hosts/master'
list[file25]='ads-and-tracking-extended.txt'
list[target25]='hosts.txt'
list[flag25]='raw'
list[ip25]='0'

list[status26]='+'
list[info26]='AdAway (Liberal: Blocks ad networks)'
list[src26]='https://adaway.org'
list[file26]='hosts.txt'
list[target26]='hosts.txt'
list[flag26]='raw'
list[ip26]='0'

list[status27]='+'
list[info27]='hostsfile.org (Very Strict: Regular blocks + porn, gambling and gaming sites)\n'
list[src27]='http://www.hostsfile.org/Downloads'
list[file27]='hosts.txt'
list[target27]='hosts.txt'
list[flag27]='raw'
list[ip27]='0'

# Others

list[status28]='+'
list[info28]='Community Whitelist (Host Flash™ whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src28]='https://gist.githubusercontent.com/VR51/7eaace2b6778ea508996/raw'
list[file28]='whitelist.txt'
list[target28]='whitelist.txt'
list[flag28]='direct'
list[ip28]='0'

list[status29]='+'
list[info29]='Community Whitelist Wild (Host Flash™ wild whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src29]='https://gist.githubusercontent.com/VR51/9798c78337fe2f7ad589/raw/'
list[file29]='whitelist-wild.txt'
list[target29]='whitelist-wild.txt'
list[flag29]='direct'
list[ip29]='0'

list[status30]='+'
list[info30]='Community Blacklist (Host Flash™ blacklist. Blocks a limited set of sites not blocked by other lists)'
list[src30]='https://gist.githubusercontent.com/VR51/ef3b90b1be2693a44f27/raw/'
list[file30]='blocklist.txt'
list[target30]='hosts.txt'
list[flag30]='direct'
list[ip30]='1'

list[status31]='+'
list[info31]='Local Whitelist (Your own custom whitelist)'
list[src31]='localhost'
list[file31]="${file[confwl]}"
list[target31]='whitelist.txt'
list[flag31]='direct'
list[ip31]='0'

list[status32]='+'
list[info32]='Local Whitelist Wild (Your own custom wild whitelist)'
list[src32]='localhost'
list[file32]="${file[confwlw]}"
list[target32]='whitelist-wild.txt'
list[flag32]='direct'
list[ip32]='0'

list[status33]='+'
list[info33]='Local blacklist (Your own custom blacklist)'
list[src33]='localhost'
list[file33]="${file[confbl]}"
list[target33]='hosts.txt'
list[flag33]='direct'
list[ip33]='1'

# GENERAL

essentialpackages=( zip unzip 7z curl sed git )
	
conf[ess]=0 # Essentials # Install build essential software. 0 = Not done, 1 = Done
conf[upv]=0 # Update Host Flash™ program.
#conf[locv]=$($binary -v) # Installed package version
conf[inst]=$( ls -l "$0" | cut -d' ' -f 6-8) # $package installation date
conf[locv]="$version installed ${conf[inst]}"
conf[gitv]=$(curl -v --silent "${rem[gith]}/commit/master" --stderr - | grep '<relative-time datetime' | sed -E 's#.+">(.+)<.+#\1#')
conf[hosts]=$( ls -l "${file[hosts]}" | cut -d' ' -f5 ) # Hosts file size
conf[hostt]=$( ls -l "${file[hosts]}" | cut -d' ' -f 6-8 ) # Hosts file timestamp
conf[hostc]=$( wc -l "${file[hosts]}" | cut -d' ' -f1 ) # Hosts file line count

conf[ip]='0.0.0.0' # Redirect IP address
conf[mode]='1' # Build Only or Build and Install 0 or 1

# LOGS
# Not yet used
function __log() {
	# @1 = Message
	
	message=$1
	
	now="$(date +"%Y-%m-%d %H:%M:%S")"
	log[$now]="$now: $message"
	
	# ${file[log]}
}

## END SETTINGS

## BEGIN 

# Other settings
bold=$(tput bold)
normal=$(tput sgr0)

# Locate where we are
filepath="$( echo $PWD )"

# A Little precaution
cd "$filepath"

# Make/Remove directories and files

function __download_tlds() {
	if test $(find "${file[conftld]}" -mmin +1440) || test ! -f "${file[conftld]}" # If exists but is older than 1440 minutes
	then
		curl -e "${rem[tld]}" "${rem[tld]}" -o "${file[conftld]}"
		sed -e 's/\(.*\)/\L\1/' "${file[conftld]}" > "${file[conftld]}tmp"
		grep -vE '^#' "${file[conftld]}tmp" > "${file[conftld]}"
		# Next lines allow the file to be passed to Grep as a string of ORs
		#grep -vE '^#' "${file[conftld]}tmp" | tr '[:space:]' '|' > "${file[conftld]}"
		#sed -i 's/[|]$//' "${file[conftld]}" # Remove superfluous | from end of file
		#rm "${file[conftld]}tmp"
	fi
}
__download_tlds # Get TLD list # Not yet used.


case "${debug}" in
	0)
		if test -d "${dir[tmp]}"; then
			rm -r "${dir[tmp]}" # Clean the tmp directory but not if we are debugging.
		fi
	;;
esac

mkdir -p "${dir[@]}" # Make directories
touch -a "${file[@]}" # Make config files


# INSTALL RC SETTINGS

function __repaint() {
# Loads configs then clears the screen
# Whatever calls this should reload the screen for the new configs to be reflected on the screen

	# @1 = type: soft, hard, conf, ret
	#  soft just refreshes the screen
	#  hard reloads the script in the current shell
	#  conf must be followed by a config file to load. Loads default conf then extra conf.
	#  'no argument' loads the default config file represented by ${file[conf]}
	# @2..@n = config file(s) to reload
	#
	# ret executes the function stated in $2
	#
	# We use $in instead of $@
	
	__clear
	
	in=( $@ )
	
	case ${in[0]} in
	
		soft) # Reset variables
			tset
	
		;;
		
		hard) # Restart this script
			exec bash "$0"
		
		;;

		conf) # Include basic conf and any extras listed in $@

		if source "${in[1]}"
		then
				for i in ${in[@]:1}; do
					source "$i"
				done
				source "${file[conf]}"
		else
				for i in ${in[@]:1}; do
					. "$i"
				done
				. "${file[conf]}"
		fi
		
		;;
		
		ret)
			$2
		
		;;

		*) # Include basic conf only

		if source "${file[conf]}"
		then
				source "${file[conf]}"
		else
				. "${file[conf]}"
		fi
		
		;;
	
	esac

}


# Include custom lists

__repaint conf "${file[confcl]}"



##
# Actions
##


function __run() {
	# Check for terminal then run else just run program
	
	tty -s
	if test "$?" -ne 0 ; then
		__launch
	else
		__menu_main "${1:-}" # This will be changed when CLI added
	fi

}

function __hosts_update() {
	# Read the file of hosts and remove any line listed in the input whitelist file
	# The results are logged in a file in the config directory.

	# @1 = type: (file) norm or wild, or (string) rem or remw
	# @2 = file to remove data from
	# @3 = file containing lines of data to remove from @2 or single line of text to remove from @2
	
	f2="$2"
	f3="$3"

	ip=$(echo "${conf[ip]}" | sed 's/\./[.]/g') # Convert periods to character group (just commenting out sometimes failed)
	
	case $1 in
		norm)
			# We tried a method that removed the while loop. It was overzealous so reverted back to while loop.
			echo -ne "\n###\n# NON-WILD WHITELIST\n###\n\n" >> "${file[confr]}"

			while read LINE ; do
				LINE=$(echo $LINE | sed 's/\./[.]/g')
				echo -ne  "\n# $LINE\n\n" >> "${file[confr]}"
				grep -i "^${ip}[[:blank:]]${LINE}"'$' "${f2}" >> "${file[confr]}" # List of hosts removed during whitelisting
				grep -vi "^${ip}[[:blank:]]${LINE}"'$' "${f2}" > "${f2}.tmp" # This method removes whitelisted hostnames
				mv -f "${f2}.tmp" "${f2}"
			done < "${f3}"

		;;

		wild)

			# Process wild whitelist to replace .TLD with all possible TLD values
			# Testing - will eventually allow for .TLD in wild whitelist to represent any valid TLD.
			# Disabled for now because it causes grep to crash while whitelisting -- too many arguments.
			#while read LINE ; do
			#	sed -r "s/^(.*)[.]TLD/\1.${LINE}/g" "$3" >> "${dir[tmp]}/wlwtmp" # Replace 'TLD' with list of possible TLDs
			#	echo '' >> "${dir[tmp]}/wlwtmp"
			#done < "${file[conftld]}"

			#grep -v "[.]TLD" "$3" >> "${dir[tmp]}/wlwtmp" # Add none .TLD$ lines back into the wild list

			echo -ne "\n###\n# WILD WHITELIST PASS 2 - WILD\n###\n\n" >> "${file[confr]}"

			while read LINE ; do
				LINE=$(echo $LINE | sed 's/\./[.]/g') # Replace periods with character group match to prevent periods being interpreted as 'any character'
				echo -ne  "\n# $LINE\n\n" >> "${file[confr]}"
				grep -i "^${ip}[[:blank:]].*[.]${LINE}" "${f2}" >> "${file[confr]}" # List of hosts removed during whitelisting
				grep -vi "^${ip}[[:blank:]].*[.]${LINE}" "${f2}" > "${f2}.tmp" # This method removes whitelisted hostnames
				mv -f "${f2}.tmp" "${f2}"
			done < "${f3}"

		;;

		linen) # Not yet used
		
			data=$3
			data=$(echo $data | sed 's/\./[.]/g') # Replace periods with character group to prevent them being interpreted as 'any character'
			# sed -r -i "s/${ip}[[:blank:]]$3.*?$//g" "$2" # Remove exact match
			grep -i "^${ip}[[:blank:]]${data}"'$' "$2" >> "${file[confr]}" # List of hosts removed during whitelisting
			grep -vi "^${ip}[[:blank:]]${data}"'$' "$2" > "$2.tmp" # This method removes whitelisted hostnames
			mv -f "$2.tmp" "$2"

		;;

		linew) # Not yet used
			data=$3
			data=$(echo $data | sed 's/\./[.]/g') # Replace periods with character group to prevent them being interpreted as 'any character'
			# sed -r -i "s/${ip}[[:blank:]].*\.$3.*?$//g" "$2" # Remove any line with a match
			grep -i "^${ip}[[:blank:]].*[.]${data}" "$2" >> "${file[confr]}" # List of hosts removed during whitelisting
			grep -vi "^${ip}[[:blank:]].*[.]${data}" "$2" > "$2.tmp" # This method removes whitelisted hostnames
			mv -f "$2.tmp" "$2"

		;;

	esac

}

function __conf_update() {
	# Add or remove a single host from the .hf*rc config files
	# ! Considered merging this function with __hosts_update. Opted to keep the two separate. It simplifies input sanitization (to come later).

	# @1 = type: add, rem, remw, or remn (remove by line number)
	# @2 = data to add/remove
	# @3 = file to add/remove @1 to/from

	d=$2
	f=$3

	case $1 in

		add)
			grep "${d}" "${f}"
			if test $? -eq 1
			then
				echo "${d}" >> "${f}"
			fi
		;;

		rem)
			sed -r -i "s/${d}.*?$//g" "${f}" # Remove exact match
			sed -i '/^$/d' "${f}" # Remove empty lines
		;;

		remw)
			sed -r -i "s/.*?${d}.*?$//g" "${f}" # Remove any line with a match
			sed -i '/^$/d' "${f}" # Remove empty lines
		;;

		remn)
			if [ $d != '' ]; then
				sed -i "${d}d" "${f}" # Remove the line number $d from the file
				sed -i '/^$/d' "${f}" # Remove empty lines
			fi
		;;
	esac
	
}

function __conf_delete() {
	__repaint conf "${file[confcl]}"
	
	# Delete specified file
	# @1 = File to delete
	# @2 = File's friendly name

	f[1]=${1}
	f[2]=${2}

	printf "${bold}DELETE CONFIG FILES${normal}"
	printf "\n\nReset chosen configuration file\n\n"

	# Display menu
	unset menu
	menu[1]="Proceed: Reset ${f[2]} by deleting file ${f[1]}"
	menu[2]="Return: Do not reset ${f[2]}"

	m=1
	while [ $m -le ${#menu[@]} ] ; do
		printf "$m) ${menu[$m]}\n"
		let m=m+1
	done
	
	printf "\nChoose an option then press Enter:\n"
	read a
	
	while true ; do
		case $a in
			1)
				if test -f "${f[1]}"; then
					rm "${f[1]}"
					printf "${f[2]} reset.\n"
					printf "\nPress any key to continue\n"
					touch "${f[1]}"
					read something
				else
					printf "${f[2]} custom settings not yet created. Nothing to do. Nothing done.\n"
					printf "\nPress any key to continue\n"
					read something
				fi
				__menu_reset_confs
			;;
			
			2)
				__menu_reset_confs
			;;
			
			*)
				__repaint
			;;
		esac
	done

}

function __remove_custom_list_entry_menu() {
	filename=$1
	description=$2

	printf "Custom $description is located at $filename\n\n"
	__display_file $filename
	printf "\nType the line number to remove then press Enter. Press 0 to exit:\n\n"
	read a

	case $a in
		0)
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;

		*)
			__conf_update 'remn' "$a" "$filename"
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;
	esac
}

function __display_file() {
	filename=$1

	n=1
	while read LINE; do
		printf "$n) $LINE\n"
		let n=n+1
	done < $filename
}

function __status() {
	# Change status of list: On or Off.
	
	# @1 = host list to change status of
	
	n=$1
	if grep "list\[status${n}]='-'" "${file[conf]}"
	then
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='+'" >> "${file[conf]}"
	else
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='-'" >> "${file[conf]}"
	fi
	
}


function __build() {
	# Build the hosts file: download lists, clean them, merge them, create new hosts file

	# Download lists. Merge them into new hosts file
	n=1
	until [ $n -eq 0 ]; do

		status="${list[status${n}]}"
		info="${list[info${n}]}"
		src="${list[src${n}]}"
		file="${list[file${n}]}"
		target="${list[target${n}]}"
		flag="${list[flag${n}]}"
		ip="${list[ip${n}]}"

		if test "$status" = '+' # The list is enabled
		then

			case "$src" in

				localhost)

					cat "$file" >> "${dir[tmp]}/$target.$n"

				;;

				*)
					# Download remote repo lists
					if test "$flag" = 'direct' # $file is the target
					then
						curl -e "$src" "$src" -o "${dir[tmp]}/$target.$n"
						mv "${dir[tmp]}/$target.$n" "${dir[tmp]}/hosts.txt.$n" # Rename target file. Helps with debugging
					fi

					if test "$flag" = 'raw'
					then
						curl -e "$src" "$src/$file" -o "${dir[tmp]}/$target.$n"
						mv "${dir[tmp]}/$target.$n" "${dir[tmp]}/hosts.txt.$n" # Rename target file. Helps with debugging
					fi

					if test "$flag" = 'unzip' || test "$flag" = 'p7zip'
					then
						curl -e "$src" "$src/$file" -o "${dir[tmp]}/$file"
						# Extract package content
						if test "$flag" = 'unzip'; then unzip -o "${dir[tmp]}/$file" -d "${dir[tmp]}"; fi
						if test "$flag" = 'p7zip'; then 7z e -y "${dir[tmp]}/$file" -o"${dir[tmp]}" ; fi
						# Rename target file. Helps with debugging
						mv "${dir[tmp]}/$target" "${dir[tmp]}/hosts.txt.$n"
					fi

					# Clean up retrieved files but keep the $target.$n

					if test -f "${dir[tmp]}/$file"
					then
						rm "${dir[tmp]}/$file"
					fi

				;;

			esac

			# Add IP address prefix if required
			case "${ip}" in

				1)
					sed -r -i "s/^/${conf[ip]} /g" "${dir[tmp]}/$target.$n" # Loopback IP
				;;

			esac

		fi

		credits+=("# Includes hosts blacklist from $info\n")

		if test ${#status} -eq 0
		then
			c=$n
			let c=c-1
			let n=n-n
		else
			let n=n+1
		fi

	done

	# Merge files. We do it this way to simplify debugging
	until [ $c -eq 0 ]; do

		echo "c: $c" >> "${dir[tmp]}/merge-counter.txt"

		if test -f "${dir[tmp]}/hosts.txt.$c"
		then
			cat "${dir[tmp]}/hosts.txt.$c" >> "${dir[tmp]}/hosts-temp.txt"
			if test $? -eq 0; then
				echo "${dir[tmp]}/hosts.txt.$c" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi

		if test -f "${dir[tmp]}/whitelist.txt.$c"
		then
			cat "${dir[tmp]}/whitelist.txt.$c" >> "${dir[tmp]}/whitelist-temp.txt"
			if test $? -eq 0; then
				echo "${dir[tmp]}/whitelist.txt.$c" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi

		if test -f "${dir[tmp]}/whitelist-wild.txt.$c"
		then
			cat "${dir[tmp]}/whitelist-wild.txt.$c" >> "${dir[tmp]}/whitelist-wild-temp.txt"
			if test $? -eq 0; then
				echo "${dir[tmp]}/whitelist-wild.txt.$c" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi
		
		let c=c-1
		
	done

	__repaint

	printf "This next part could take some time.\nLook in ${dir[tmp]} to view activity in realtime.\n\nProcessing...\n"

	# Convert non-UTF8 characters to UTF8. Fix characters in French lists.
	# And remove empty lines from whitelists

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmp]}/whitelist-temp.txt" > "${dir[tmp]}/whitelist-temp-copy.txt"
	sed '/^$/d' "${dir[tmp]}/whitelist-temp-copy.txt" > "${dir[tmp]}/whitelist-temp.txt"
	rm "${dir[tmp]}/whitelist-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmp]}/whitelist-wild-temp.txt" > "${dir[tmp]}/whitelist-wild-temp-copy.txt"
	sed '/^$/d' "${dir[tmp]}/whitelist-wild-temp-copy.txt" > "${dir[tmp]}/whitelist-wild-temp.txt"
	rm "${dir[tmp]}/whitelist-wild-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmp]}/hosts-temp.txt" > "${dir[tmp]}/hosts-temp-copy.txt"
	rm "${dir[tmp]}/hosts-temp.txt"

	#	Format raw list data in hosts-temp.txt

	grep -v '^#' "${dir[tmp]}/hosts-temp-copy.txt" > "${dir[tmp]}/hosts-temp.txt" # Remove all lines that begin with a comment
	sed -r -i 's/[[:blank:]]+/ /g' "${dir[tmp]}/hosts-temp-copy.txt" # Convert spaces and tabs each to a single space
	grep -Ev "[[:blank:]](ip6-)?(localhost|loopback|localnet|mcastprefix|allnodes|allrouters)\s?\b" "${dir[tmp]}/hosts-temp-copy.txt" > "${dir[tmp]}/hosts-temp.txt" # Remove localhost lines - the computer's installed host file already has localhost defined the way it should be
	grep -E '^[012][\.01-9]{1,2}' "${dir[tmp]}/hosts-temp.txt" > "${dir[tmp]}/hosts-temp-copy.txt" # Remove any line that does not begin with 0,1 or 2
	sed -r -i "s/^[012][\.01-9]{1,2}+[[:blank:]]/${conf[ip]} /g" "${dir[tmp]}/hosts-temp-copy.txt" # Replace with a single space and the new IP address everything up to, and including, the first tab in each line

	# Sort the lists
	if test -f "${dir[tmp]}/hosts-temp-copy.txt"
	then
		sed -i 's/\r$//' "${dir[tmp]}/hosts-temp-copy.txt" # Standardise line endings
		sort -f -u "${dir[tmp]}/hosts-temp-copy.txt" > "${dir[tmp]}/hosts-temp.txt"
		rm "${dir[tmp]}/hosts-temp-copy.txt"
	fi

	if test -f "${dir[tmp]}/whitelist-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmp]}/whitelist-temp.txt" # Fix line endings
		sort -f -u "${dir[tmp]}/whitelist-temp.txt" > "${dir[tmp]}/whitelist.txt"
		rm "${dir[tmp]}/whitelist-temp.txt"
	fi

	if test -f "${dir[tmp]}/whitelist-wild-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmp]}/whitelist-wild-temp.txt" # Fix line endings
		sort -f -u "${dir[tmp]}/whitelist-wild-temp.txt" > "${dir[tmp]}/whitelist-wild.txt"
		rm "${dir[tmp]}/whitelist-wild-temp.txt"
	fi

	# Process whitelist -- remove whitelisted domains from hosts-temp.txt
	# Always pass wild through norm too
	__hosts_update "norm" "${dir[tmp]}/hosts-temp.txt" "${dir[tmp]}/whitelist.txt"
	__hosts_update "norm" "${dir[tmp]}/hosts-temp.txt" "${dir[tmp]}/whitelist-wild.txt"
	__hosts_update "wild" "${dir[tmp]}/hosts-temp.txt" "${dir[tmp]}/whitelist-wild.txt"
	
	# hosts.txt should not exist at this point
	if test -f "${dir[tmp]}/hosts.txt"
	then
		rm "${dir[tmp]}/hosts.txt"
	fi

	#	Get head of the existing hosts file stored at /etc/hosts
	#	Remove old Host Flash™ blacklist from existing hosts file, assuming blacklist exists
	#	Remove empty lines from the end of the header
	#	This creates file hosts.head which is used a few lines down from here

	if grep -zPo '# Host.? Flash' "${file[hosts]}"
	then
		grep -zPo '(?s).*# Host.? Flash' "${file[hosts]}" | head -n -1 | grep -v '^[[:space:]]$' > "${dir[tmp]}/hosts.head" # Remove old HF data, remove HF header remove empty lines.
	else
		cp "${file[hosts]}" "${dir[tmp]}/hosts.head" # No existing hostsfile so just copy hosts to hosts.head
	fi

	printf '\n\n# Host Flash™ Firewall\n\n# Credits\n\n' >> "${dir[tmp]}/hosts.head" # Add HF heading

	for i in "${credits[@]}" ; do
		printf "$i" >> "${dir[tmp]}/hosts.head" # Add HF list provider credits
	done

	printf "\n\n# Installed with $package\n\n# Visit host-flash.com to learn more\n\n" >> "${dir[tmp]}/hosts.head" # Add HF credit

	cat "${dir[tmp]}/hosts.head" "${dir[tmp]}/hosts-temp.txt" > "${dir[src]}/hosts.txt" # Merge the old head with the new hosts blacklist

}

function __enable() {
	# Install Host Flash™ hosts list to /etc/hosts

	echo
	# Get su authority
	sudo -v

	# Backup original hosts file before first ever use of Host Flash™ in this system.
	# Only happens if it does not yet exist.
	if test ! -f "${file[hosts]}.hf.original"
	then
		sudo cp "${file[hosts]}" "${file[hosts]}.hf.original"
	fi

	if test -f "${dir[src]}/hosts.txt"
	then
		sudo cp "${file[hosts]}" "${file[hosts]}.hf.backup" # General restore file
		sudo mv -f "${dir[src]}/hosts.txt" "${file[hosts]}" # New hosts file
	else
		message[enable]="$package hosts file not found. Have you built it yet?"
	fi

	# Help the new hosts file take effect.
	__cleandns
	
	sudo -k

}

function __disable() {
	# Remove Host Flash™ hosts list from /etc/hosts

	echo
	# Get su authority
	sudo -v
	
	cp "${file[hosts]}" "${dir[tmp]}/hosts.copy"
	if grep -zPo '# Host.? Flash.? Bad Hosts Block' "${dir[tmp]}/hosts.copy"
	then
		# Remove old HF data, remove HF header remove empty lines.
		grep -zPo '(?s).*# Host.? Flash.? Bad Hosts Block' "${dir[tmp]}/hosts.copy" | head -n -1 | grep -Ev '^[[:space:]]$' > "${dir[tmp]}/hosts.head"
		sudo mv -f "${dir[tmp]}/hosts.head" "${file[hosts]}"
	else
		message[disable]="$package not installed. Nothing to do."
	fi

	# Help the new hosts file take effect.
	__cleandns
	
	sudo -k

}

function __cleandns() {
	# Clean the DNS local servers. We try them all.. just in case.

	flush=(
	'systemd-resolve --flush-caches' # General
	'service network-manager restart' # Debian
	'systemctl restart network.service' # Systemd
	'systemctl restart wicd.service' #  Systemd for WICD
	'systemctl restart NetworkManager.service' # Fedora, Manjaro, Arch using Network Manager
	'service nscd restart' # FreeBSD
	'/etc/init.d/network restart' # RHEL/Centos'
	'/etc/init.d/dns-clean restart' # Mint'
	'/etc/init.d/nscd restart' # other
	'/etc/init.d/networking force-reload' # Other
	'/etc/init.d/dnsmasq restart' # Other
	)
	
	sudo -v

	for i in "${flush[@]}"; do
		printf "${bold}Attempting to flush DNS cache ${normal} using command: $i\n"
		sudo $i
		printf "Do not worry if the above says 'fail'. We only need one success.\n\n"
	done
	
	sudo -k

}

##
# MENUS
##


# Main Menu

function __menu_main() {

	__repaint conf "${file[confcl]}"

	# $1 = instruction

	while true; do

		if test "$?" -eq 0
		then

			case "${conf[mode]}" in

					0)
						mode[0]='MODE: Build Hosts Firewall Only\n'

					;;

					1)
						mode[0]='MODE: Build and Install Hosts Firewall\n'

					;;

			esac

			# Set Menu Options

			unset menu
			menu[1]='List Management (enable or disable repositories)'
			menu[2]='Custom List Management (add or remove whitelist/blacklist rules)\n'

			menu[3]="[${conf[ip]}] - Change redirect IP address\n"

			menu[4]='Change Build/Install Mode\n'

			case "${conf[mode]}" in

				0)
					menu[5]='Build Host Flash™ list but do not install.\n'

				;;

				1)
					menu[5]='Build and Install Host Flash™ list.\n'

				;;

			esac

			menu[6]='Enable Host Flash™ list.'
			menu[7]='Disable Host Flash™ list.'
			case "${conf[mode]}" in

				0)
					menu[8]='Update hosts file with new custom rules but do not enable new hosts file\n'

				;;

				1)
					menu[8]='Update and Enable hosts file with new custom rules\n'

				;;

			esac
			menu[9]='Flush DNS rules\n'

			menu[10]='Restore original hosts file.\n'

			menu[11]="Reset $package configs and files (select in next menu)"

			case "${conf[ess]}" in

				0)
					menu[1000]='Install missing software packages needed by Host Flash™\n'

				;;

			esac

			printf $bold
			printf "${mode[0]}\n"
			printf $normal

			printf "MENU\n\n"

			n=1
			for i in "${menu[@]}"; do
				if [ "$i" == '' ]; then
					printf "\n"
				else
					printf "$n) $i\n"
					select[$n]=$n
					let n=n+1
				fi
			done

			printf "\nR) Restart $package\n"
			printf "\n0) Exit\n\n"

			# Instructions
			
			printf "INSTRUCTIONS: a) Select lists to install with option 1, b) optionally add custom domains to blacklist or whitelist, c) build the hosts file firewall with option 5, before you d) Enable the newly built hosts file firewall with option 6. Change MODE to 'Build and Install' to set $package to automatically install the hosts file after it is built. $package will only work if the Essential Software is installed.\n\n"
			
			# Notices

			printf $bold

			printf "\nGENERAL INFO\n"
				
			printf $normal

			printf "\n System $package: ${conf[locv]}"
			printf "\n Latest git commit: ${conf[gitv]}\n"
			printf "\n Hosts File Info: Line Count: ${conf[hostc]} | Bytes: ${conf[hosts]} | Timestamp: ${conf[hostt]} | Location: ${bold}${file[hosts]}${normal}\n"

			printf "\nIf the computer crashes during installation lower the number of lists processed or cool your computer then try again.\n"

			printf $bold
				printf "\nChoose Wisely: "
			printf $normal
			read REPLY
		
		else
			REPLY=$1
		fi

		case $REPLY in

		1) # Choose lists to download # When moved to its own menu this will only be [[:num:]]
			__menu_list_management

		;;
		
		2) # Manage custom whitelists and blacklists
			__menu_custom_list_management
			
		;;

		3) # Change redirect IP address

			printf "Current Redirect IP: ${conf[ip]}"
			printf "\nType in new Redirect IP then press Enter:\n\n"
			read ip

			if grep "conf\[ip]=" "${file[conf]}"
			then
				sed -i "s/conf\[ip]='.*'/conf\[ip]='$ip'/g" "${file[conf]}"
			else
				echo -e "conf""[ip]='$ip'" >> "${file[conf]}"
			fi

			__repaint

		;;

		4) # Set Mode

			if grep "conf\[mode]='0'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='0'/conf\[mode]='1'/g" "${file[conf]}"
				
			elif grep "conf\[mode]='1'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='1'/conf\[mode]='0'/g" "${file[conf]}"
				
			else
				echo -e "conf""[mode]='1'" >> "${file[conf]}"
			fi

			__repaint

		;;

		5) # Build or Build and Install the Host Flash™ hosts file

			__build
			
			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;

		6) # Enable Host Flash™ hosts list

			__enable
			__repaint

		;;

		7) # Disable Host Flash™ hosts list

			__disable
			
			if test "${message[disable]}"
			then
				printf "\n${message[disable]}\nPress any key."
				read -a
			fi

			__repaint

		;;

		8) # Update hosts file with new custom rules

			__clear

			printf "This next part could take some time.\nLook in ${dir[tmp]} to view activity in realtime.\n\nProcessing...\n"

			cp "${file[hosts]}" "${dir[tmp]}/hosts-temp.txt"
			cat "${dir[tmp]}/hosts-temp.txt" "${file[confbl]}" >> "${dir[tmp]}/hosts.txt"
			
			# Always pass wild through norm too
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwl]}"
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"
			__hosts_update "wild" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"

			mv -f "${dir[tmp]}/hosts.txt" "${dir[src]}/hosts.txt"

			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;
		
		9)
			__clear
			__cleandns
			printf "\nPress any key"
			read a
			__repaint
		
		;;

		10) # Restore original hosts list

			if test -f "${file[hosts]}.hf.original"
			then # Restore the backup head from the original hosts file
				sudo mv -f "${file[hosts]}.hf.original" "${file[hosts]}"
			fi

			__repaint

		;;

		11) # Reset Custom Configs

			__menu_reset_confs

			__repaint hard

		;;

		12) # Install software packages necessary to build the package

			case "${conf[ess]}" in
			
				0)

					printf "\nThis will attempt to install the following packages:\n"

					for i in "${essentialpackages[@]}"; do
						printf "$i "
					done

					printf "\nContinue to install them: Yn:\n"
					read a
					
					let n=1
					while true; do
						case $a in

						y|Y)
						
							case $n in
							1)
								echo -e "conf""[ess]='1'" >> "${file[conf]}"
								sudo apt-get update
								let n=n+1
							;;
							esac
							
							for i in "${essentialpackages[@]}"; do
								sudo apt-get build-dep -y -q $i
								sudo apt-get install -y -q --install-suggests $i
							done

							printf "\nPress any key to continue\n"
							read something
							__repaint

						;;

						n|N)

							__repaint

						;;
						
						*)

						esac
						
					done
					
				;;
				
			esac

		;;
		
		[Rr])
			__repaint hard
		;;

		0) # Exit

			exit 0

		;;

		*)

		esac

	done

}


# Sub Menus

function __menu_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"
		
		# Display lists available
		# $listsc # Value discovered during list array auto declares (see above)
		
		n=1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter list number to enable [+] or disable [-] then press Enter.\n"
		printf "\nType ${bold}E${normal} to Add, Remove or Edit remote hosts list providers.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			[Ee])
				__menu_remote_list_management

			;;

			*)
				__status $a
				__repaint conf "${file[confcl]}"
			;;

		esac

	done
}

function __menu_remote_list_management() {
	# Add or Remove new remote list providers

	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT: CUSTOM REMOTE SOURCES${normal}"
		printf "\n\nCustom remote list resources\n\n"
		
		# Display custom remote lists available for management
		# $listsc # Value discovered during list array auto declares (see above)

		let n=$listc+1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done

		printf "\n${bold}A${normal}) to Add a custom remote hosts list provider\n"
		printf "${bold}D${normal}) to Delete a custom remote hosts list provider\n"
		printf "${bold}E${normal}) to Edit a custom remote hosts list provider\n"
		printf "\n0) Return to Main Menu\n"

		read a

		case $a in

			0)
				__menu_main
			;;

			[Aa])

				__clear

				printf "\nEnter details for new resource list ${n}.\n\n"
				
				__conf_update 'add' "list[status${n}]='+'" "${file[confcl]}"

				printf "Enter brief list description: "
				read a
				__conf_update 'add' "list[info${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the download URL e.g https://example.com/download-page.\nDo not include the package/file name or a trailing slash: "
				read a
				__conf_update 'add' "list[src${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package name: "
				read a
				__conf_update 'add' "list[file${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package type e.g unzip, p7zip, direct or raw: "
				read a
				__conf_update 'add' "list[flag${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the target file name that contains the hosts data: "
				read a
				__conf_update 'add' "list[target${n}]='${a}'" "${file[confcl]}"

				printf "\nDo all hostnames in this list need an IP address prefix? (1 for Yes, 0 for No): "
				read a
				__conf_update 'add' "list[ip${n}]='${a}'" "${file[confcl]}"

				printf "\nList ${n} added to hosts file repository. $package will restart after you press Enter.\n"
				read a
				
				__repaint hard

			;;

			[Dd])

				printf "\nEnter list number to delete.\n"
				read a

				__conf_update 'remw' "${a}]" "${file[confcl]}"

				printf "\nList ${a} deleted from hosts file repository. $package will restart after you press Enter.\n"
				read a

				__repaint hard
				
			;;

			[Ee])
				# To be implemented
					__repaint hard
			;;

			*)

			;;

		esac

	done
}


function __menu_custom_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}CUSTOM LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"

		# Display custom list options
		unset menu
		menu[1]="Add a host to custom whitelist"
		menu[2]="Add a host to custom wild whitelist"
		menu[3]="Add a host to custom blacklist\n"
		menu[4]="Remove a host from custom whitelist"
		menu[5]="Remove a host from custom wild whitelist"
		menu[6]="Remove a host from custom blacklist\n"
		menu[7]="Display custom whitelist"
		menu[8]="Display custom wild whitelist"
		menu[9]="Display custom blacklist"

		n=1
		for i in "${menu[@]}" ; do
			printf "$n) ${i}\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter option number then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Add to custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a
				
				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			2) # Add to custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwlw]}" # Add host to wild whitelist
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			3) # Add to custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confbl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			4) # Remove from custom whitelist

				__remove_custom_list_entry_menu ${file[confwl]} "whitelist"

			;;

			5) # Remove from custom wild whitelist

				__remove_custom_list_entry_menu ${file[confwlw]} "wild whitelist"

			;;

			6) # Remove from custom blacklist

				__remove_custom_list_entry_menu ${file[confbl]} "blacklist"

			;;

			7) # Display custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				cat "${file[confwl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			8) # Display custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				cat "${file[confwlw]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			9) # Display custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				cat "${file[confbl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			*)


			;;

		esac

	done
}

function __menu_reset_confs() {

	__repaint conf "${file[confcl]}"

	while true; do

		printf "${bold}CUSTOM CONFS MANAGEMENT${normal}"
		printf "\n\nReset custom lists and configurations\n\n"

		# Display menu
		unset menu
		menu[1]="Reset general configurations to their default values"
		menu[2]="Delete custom host file repository lists"
		menu[3]="Delete custom whitelist"
		menu[4]="Delete custom whitelist wild"
		menu[5]="Delete custom blacklist"
		menu[6]="Delete log of removed hosts"
		menu[7]="Delete general log"
		menu[8]="Delete debug log"

		m=1
		while [ $m -le ${#menu[@]} ] ; do
			printf "$m) ${menu[$m]}\n"
			let m=m+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter item number to action then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Reset confs[]
				__conf_delete "${file[conf]}" "$package custom configuration"

			;;

			2) # Delete custom host lists
				__conf_delete "${file[confcl]}" "Custom host file repositories"

			;;

			3) # Delete custom whitelist
				__conf_delete "${file[confwl]}" "custom whitelist"
			;;

			4) # Delete custom whitelist wild
				__conf_delete "${file[confwlw]}" "custom whitelist wild"

			;;

			5) # Delete custom blacklist
				__conf_delete "${file[confbl]}" "custom blacklist"

			;;

			6)
				__conf_delete "${file[confr]}" "removed hosts log"

			;;

			7)
			__conf_delete "${file[log]}" "removed hosts log"

			;;

			8)

			;;

			*)
				__repaint conf "${file[confcl]}"
			;;

		esac

	done

	__repaint conf "${file[confcl]}"

}


## Launch

function __launch() {
	# launch terminal

	terminal=( konsole gnome-terminal x-terminal-emulator xdg-terminal terminator urxvt rxvt Eterm aterm roxterm xfce4-terminal termite lxterminal xterm )
	for i in ${terminal[@]}; do
		if command -v $i > /dev/null 2>&1; then
			exec $i -e "$0"
			# break
		else
			printf "\nUnable to automatically determine the correct terminal program to run e.g Console or Konsole. Please run this $package from the command line.\n"
			read something
			exit 1
		fi
	done
}

## Debug Flags

case "${debug}" in

	1)

		#exec 3>&1 4>&2
		#trap 'exec 2>&4 1>&3' 0 1 2 3
		#exec 2>&1 >> "${file[log]}"
		exec 2>> "${file[debug]}"
	;;
	
esac

## Boot
__run "$@" # Loops back to the start. The script is read by BASH then __run is run. This ensures all functions are read into memory before anything happens.

# Exit is at end of __run()

# FOR DEBUGGING

# declare -p
