#!/bin/bash
# set -euo pipefail
# set -x
IFS=$'\n\t'
###
# Host Flash™ 4.0.0
#
# Downloads hosts file rules from various sources.
# Installs hosts file rules into /etc/hosts
# Integrates Host Flash™ hosts file rules with rules that already exist in /etc/hosts
#
# For OS: Linux (Debian)
# Tested With: Ubuntu flavours
#
# Lead Author: Lee Hodson<https://github.com/vr51//>
# Contributor: skeletonkey<https://github.com/skeletonkey/>
# Donate: https://paypal.me/vr51
# Website: https://host-flash.com<https://host-flash.com>
# This Release: 3rd July 2020
# First Written: 18th Oct. 2015
# First Release: 2nd Nov. 2015
#
# Copyright Host Flash™ https://host-flash.com<https://host-flash.com>
# License: GPL3
#
# Programmer: Lee Hodson<journalxtra.com>, VR51<vr51.com>
#
# Use of this program is at your own risk
#
# INSTALLS OR UPDATES
#
# Use Host Flash™ to block access to websites (hosts), ad servers, malicious websites and time wasting websites.
# Use Host Flash™ to manage your hosts file
#
# TO RUN:
#
# Ensure the script is executable:
#
#  Right-click > properties > Executable
#
#  OR
#
#  chmod u+x hostflash
#
# Launch by clicking the script file or by typing `bash ./hostflash` at the command line.
#
# Host Flash™ will attempt to preserve existing host rules.
#
###

##
#	NEW in 4
#		Auto-detect source file type. No need to flag the file type in custom lists. The now obsolete flags were: zip, p7, raw and direct.
#		New directory structure
#			Permanent Directories
#				~/hostflash/backups
#				~/hostflash/DOCS
#				~/hostflash/logs
#			Temp. Directories. These are deleted when a new hosts file is built (unless DEBUG is set to '1', in which case they are left in place)
#				~/src/tmp/download
#				~/src/tmp/unprocessed
#				~/src/tmp/processed
#			Config Directory restructure
#				~/.configs/.hostflash
#				~/.configs/hostflash/.lists # To be used later
#				~/.configs/hostflash/.menus # To be used later
#				~/.configs/hostflash/.plugins # To be used later
#
#		Replaced hosts files are now zipped to the backup directory. Restore option to be added later.
#		Hosts file summary info is now written to the history log when a host file is built.
#		__log now logs three message types: log, hist and debug. The __debug will eventually be rolled into __log.
#		__log with 'debug' flag causes cURL to log to the debug file the head fetched with source file downloads.
#
##

##
# TO DO / DEV NOTES
#	Please feel free to work through this list if you wish to help the project.
#
#
#
#
# line 1583 fix restore. should point to backup directory and unzip into tmp directory then test for hosts before moving it to /etc/hosts
##
#
# Modularisation
#		Host Flash is meant to be a single file downloadable script. 
#		I (Lee) might convert the script to an installer that chops itself up to extract modules.
#		This would enable Host Flash to accept plugins, facilitate user customizations and facilitate HF's future development.
#		TBC...
#
#	Use one file per list.
#	Download Free Mode. Place source files into directory. HF builds from source files.
#	Rebuild source file process method
#
#	If internet is available (Check exit status of latest Git commit check: $networked should = 0 if the net is available)
#		Download DOCs
#		Offer HF script updates
#	Show error if internet is unavailable
#
# versions: add deb installer
#
#  En/disable Automatic list update
#  En/disable Automatic script update
#
# CLI: disable HF, enable HF, add rule, remove rule, update lists, set options
#
# List Build Options
#  Build pure list. No whitelisting
#   Check whitelists (extracted, found, not found) # To be integrated from standalone file.
#    Rebuild whitelists after check
#  Build filtered list. Whitelisting done
#   Install after build
#   Do not install after build
# Compact local whitelists and local blacklists (all lower, sort -u)
# View/Edit local lists (nano, pico, cat)
#
# Feature: search hosts file for a domain or list of domains (grep without regex)
#  Offer to disable if found
#  Offer to add to custom whitelist
#
# Switchlist
#  Temporarily disable and enable whitelist hosts
# Options
#  Check .hfremoved list # Script written and tested ready for insertion
#   Move items from .hfremoved to post processing blacklist
#   Move items from .hfremoved to Switch List
#
# Move more actions into functions.
# Tidy up
# Add input checking/sanitisation
# Make messages and menus clearer
# Menu + View all HF configs
#
# Summary info on main screen / maybe footer for all screens
#  Add more useful info
#  Include link to host-flash.com
#
#  Info about each list
#   Last update time
#
# Go through functions to state the output format
# 
# Rebuild menu system based on SaLi text mode only
###

##
# NOTES
#
# Hosts File Build Process
#
#  The host file work is done in $HOME/src/hostflash/tmp. This eventually builds hosts.txt
#  The final build of hosts.txt is moved to $HOME/src/hostflash/
#  __enable looks for $HOME/src/hostflash/hosts.txt which it moves to /etc/hosts
#
# Whitelist Processing
#
#  Whitelist wild is processed twice:
#   As a normal whitelist
#   As a wild whitelist
#   A period is added before the first character of each host name processed
##

##
# CONFIGS ARE BELOW HERE - should be no reason to manually change these
#
# Any of these can be overruled by adding each variable along with its new value into $HOME/.config/hostflash/.hfrc
# Adding config changes to $HOME/.config/hostflash/.hfrc will protect changes from script version updates.
##

# IMPORTANT: Do not Use trailing slashes in URLs, URIs or directory paths

package='Host Flash™' # Name of software installed by this installer
version='4.0.0 - 3rd June 2020'
debug='0'

## Clear screen
function __clear() {
	if test $debug -eq '0' ; then
		clear
	fi
}

## Source loader
# Load source files
# This facilitates modularisation
function __flying_sourcer() {

	SourcerSection="$1"
	
	if source "${SourcerSection}"
	then
		source "${SourcerSection}"
	else
		. "${SourcerSection}"
	fi

}

# Clear arrays
unset app conf dir file in list log message rem menu select mode essentialpackages credits flush listc listcc listsc

# Declare associative arrays
declare -A app conf dir file list log message rem

# Declare regular arrays and types
declare -a menu # Menu options are set within __menu_main()
declare -a select # Menu options count
declare -a mode # Used for notices
declare -a essentialpackages # Packages to install to help the build process
declare -a credits # Hosts file credits
declare -a flush # DNS cache flush commands
declare -i listc listcc listsc # For list repository counts

# Remote Hosts
rem[gith]='https://github.com/VR51/host-flash' # Github home URL for this package.
rem[gitp]='https://github.com/VR51/host-flash.git' # Software source package git address
rem[tld]='https://data.iana.org/TLD/tlds-alpha-by-domain.txt' # Official list of valid TLDs

# Directories
#  These directories are created by dir[@] dump. Be careful when adding directories to this list
#
# Top level directories
dir[hfh]="$HOME/hostflash" # Host Flash Home directory
dir[src]="$HOME/src/hostflash" # Directory where source hosts files are stored locally
dir[conf]="$HOME/.config/hostflash" # Location of custom configuration files.
# Sub level directories
## These are permanent doc and log directories
dir[docs]="${dir[hfh]}/DOC" # Location of program documents. # To be written
dir[logs]="${dir[hfh]}/logs" # Location of host file logs.
dir[bck]="${dir[hfh]}/backups" # Location of host file backups.
## These are config directories
dir[lists]="${dir[conf]}/lists" # Modular lists
dir[menus]="${dir[conf]}/menus" # Modular menus
dir[plugs]="${dir[conf]}/plugins" # Modular plugins
## These are wiped each time a hosts file is built unless DEBUG is set to '1'.
dir[tmp]="${dir[src]}/tmp" # Directory where temporary files are stored locally
dir[tmpd]="${dir[tmp]}/downloads" # Directory where source hosts files downloaded and unpacked before being moved
dir[tmpu]="${dir[tmp]}/unprocessed" # Directory where unprocessed source hosts files are stored
dir[tmpp]="${dir[tmp]}/processed" # Directory where processed source hosts files are stored. This allows us to check events.

# Files
file[hosts]=''
# System hosts file location. Where it is copied from and where it is installed to.
# file[hosts]='/etc/hosts' # Location of system hosts file in Unix, Unix-like and POSIX systems.
# file[hosts]='/private/etc/hosts' # iOS, Apple Mac
# file[hosts]='/system/etc/hosts' # Android
# file[hosts]='%SystemRoot%\System32\drivers\etc\hosts' # Windows NT, 2000, XP,[5] 2003, Vista, 2008, 7, 2012, 8, 10

# Custom Hosts File location
# file[hosts]='/enter/path/to/file/called/hosts' # Add the path to your system's hosts file then uncomment (remove the #) and save to activate.

__clear

if test ! "${file[hosts]}"; then
	if test -f "/system/etc/hosts"; then
		file[hosts]='/system/etc/hosts'
	elif test -f "/private/etc/hosts"; then
		file[hosts]='/private/etc/hosts'
	elif test -f "/etc/hosts"; then
		file[hosts]='/etc/hosts'
	else
		echo "Unable to detect the location of this system's hosts file."
		echo "Please edit the hostflash program at around line 175 to set a custom value for ${bold}file[hosts]${normal} to point to your system's hosts file"
		echo "and uncomment the line edited."
		echo "Alternatively, add ${bold}file[hosts]='/path/to/your/hosts'${normal} to ${bold}$HOME/.config/hostflash/.hfrc${normal} if the change should survive script updates."
		echo "Visit ${bold}${rem[gith]}${normal} if you want us to add your host file's location to the automatic detection list."
		echo "Press any key to exit $package"
		read a
		exit 1
	fi
fi

# HF Config Files
#  These are created by file[@] dump. Be careful when adding files to this list
file[conf]="${dir[conf]}/.hfrc" # Location of user's custom settings for Host Flash™.
file[confwl]="${dir[conf]}/.hfwlrc" # Location of the user's custom whitelist.
file[confwlw]="${dir[conf]}/.hfwlwrc" # Location of the user's custom whitelist-wild.
file[confbl]="${dir[conf]}/.hfblrc" # Location of the user's custom blacklist.
file[confcl]="${dir[conf]}/.hfclrc" # Location of the user's custom hosts lists.
file[confr]="${dir[conf]}/.hfremoved" # Hosts removed from hosts list during hosts build/update.
file[conftld]="${dir[conf]}/.hftld" # Location of valid TLD list.
# Log files
file[hist]="${dir[logs]}/history.txt" # Location of update history.
file[log]="${dir[logs]}/log.txt" # Location of the general process log file. # Not yet used
file[debug]="${dir[logs]}/debug.txt" # Location of debug logging file.
# Next files to be used in a later version of HF
file[confpost]="${dir[conf]}/.hfpost" # Location of the post processing blacklist (block hosts that are wild needlessly whitelisted)
file[confsl]="${dir[conf]}/.hfslrc" # Location of the user's hosts switch list.

# App Launcher Settings
# These are specific to the application/task manager installer (yet to be implemented)
app[icon]="${dir[src]}/data" # Directory where the application icon will be located.
app[bin]='/usr/bin' # Binary installation path. Where should the compiled binary be installed to? Exact path. # Not required for this installer.
app[icon]="hostflash.svg" # Icon name
app[type]='Application' # 
app[cats]='Utilities' # Application launcher categories
app[binary]="hostflash" # Name of the binary file that is this program.

# Detected settings
user=$(whoami) # Current User
group=$(id -g -n $user) # Current user's primary group

###
# DECLARE LIST ARRAYS
###

# Declare custom list associative arrays. If they are not declared we cannot use them.

# Count Lists
listc=$(grep -E '\[status[[:digit:]]+]=' "$0" | wc -l) # Count lists in hostflash script
if test $(grep -En '\[status[[:digit:]]+]=' "${file[confcl]}")
then
	listcc=$(grep -E '\[status[[:digit:]]+]=' "${file[confcl]}" | wc -l) # Count custom lists in .hfclrc
else
	listcc=0
fi
let listsc=listc+listcc

##
# LISTS
#
# These are set with
#
# list[status]='Enabled / Disabled' # + or - for TRUE or FALSE
# list[info]='List Domain' # The name of the list
# list[src]='Download URL' # From where the package will be retrieved
# list[file]='Download Package' # Name of package retrieved
# list[target]='Package Target' # Name of usable file in a retrieved zip package / Name of file created on retrieval if FLAG is raw
# list[ip]='0' # 0 or 1 for false or true. Add loopback IP address to downloaded list. This is required when a hosts list consists of domain names with no IP prefix. Not required for whitelists, in fact should never be set to '1' for whitelists.
#
# Changes to list[status] are stored in .hfrc
# Custom lists will be added to .hfclrc
#		Framework in place: conf etc... Needs menu section to be added.
##

# TO DO: Change to list[NUM TYPE]
#  https://hosts-file.net/?s=Download <-- DEAD. This is now a Malwarebytes browser addon.
#  Files from here now mirrored and updated at https://github.com/fredprod/host-file.net-backup
#  & https://github.com/blackskye-sx/host-file.net-backup
list[status1]='+'
list[info1]='hosts-file.net - Ad Servers (Liberal)'
list[src1]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file1]='ad_servers.txt'
list[target1]='ad_servers.txt'
list[ip1]='0'

list[status2]='+'
list[info2]='hosts-file.net - EMD (Liberal)'
list[src2]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file2]='emd.txt'
list[target2]='emd.txt'
list[ip2]='0'

list[status3]='+'
list[info3]='hosts-file.net - EXP (Liberal)'
list[src3]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file3]='exp.txt'
list[target3]='exp.txt'
list[ip3]='0'

list[status4]='+'
list[info4]='hosts-file.net - FSA (Liberal)'
list[src4]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file4]='fsa.txt'
list[target4]='fsa.txt'
list[ip4]='0'

list[status5]='+'
list[info5]='hosts-file.net - GRM (Liberal)'
list[src5]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file5]='grm.txt'
list[target5]='grm.txt'
list[ip5]='0'

list[status6]='+'
list[info6]='hosts-file.net - HFS (Liberal)'
list[src6]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file6]='hfs.txt'
list[target6]='hfs.txt'
list[ip6]='0'

list[status7]='+'
list[info7]='hosts-file.net - HJK (Liberal)'
list[src7]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file7]='hjk.txt'
list[target7]='hjk.txt'
list[ip7]='0'

list[status8]='+'
list[info8]='hosts-file.net - MMT (Liberal)'
list[src8]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file8]='mmt.txt'
list[target8]='mmt.txt'
list[ip8]='0'

list[status9]='+'
list[info9]='hosts-file.net - PHA (Liberal)'
list[src9]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file9]='pha.txt'
list[target9]='pha.txt'
list[ip9]='0'

list[status10]='+'
list[info10]='hosts-file.net - PSH (Liberal)'
list[src10]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file10]='psh.txt'
list[target10]='psh.txt'
list[ip10]='0'

list[status11]='+'
list[info11]='hosts-file.net - PUP (Liberal)'
list[src11]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file11]='pup.txt'
list[target11]='pup.txt'
list[ip11]='0'

list[status12]='+'
list[info12]='hosts-file.net - WRZ (Liberal)'
list[src12]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file12]='wrz.txt'
list[target12]='wrz.txt'
list[ip12]='0'

list[status13]='+'
list[info13]='mvps.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Big list)'
list[src13]='https://winhelp2002.mvps.org'
list[file13]='hosts.zip'
list[target13]='HOSTS'
list[ip13]='0'

list[status14]='+'
list[info14]='free.fr-Trackers (Moderate: Blocks trackers)'
list[src14]='http://rlwpx.free.fr/WPFF'
list[file14]='htrc.7z'
list[target14]='Hosts.trc'
list[ip14]='0'

list[status15]='+'
list[info15]='free.fr-Ad-Servers (Moderate: Blocks ad servers)'
list[src15]='http://rlwpx.free.fr/WPFF'
list[file15]='hpub.7z'
list[target15]='Hosts.pub'
list[ip15]='0'

list[status16]='+'
list[info16]='free.fr-Malware (Moderate: Blocks malware domains)'
list[src16]='http://rlwpx.free.fr/WPFF'
list[file16]='hrsk.7z'
list[target16]='Hosts.rsk'
list[ip16]='0'

list[status17]='+'
list[info17]='free.fr-Adult (Moderate: Blocks adult domains. Coincidentally blocks forums and some social sites)'
list[src17]='http://rlwpx.free.fr/WPFF'
list[file17]='hsex.7z'
list[target17]='Hosts.sex'
list[ip17]='0'

list[status18]='+'
list[info18]='free.fr-Misc (Moderate: Blocks miscellaneous domains)'
list[src18]='http://rlwpx.free.fr/WPFF'
list[file18]='hmis.7z'
list[target18]='Hosts.mis'
list[ip18]='0'

list[status19]='+'
list[info19]='someonewhocares.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Small list)'
list[src19]='https://someonewhocares.org/hosts'
list[file19]='hosts'
list[target19]='hosts.txt'
list[ip19]='0'

list[status20]='+'
list[info20]='malwaredomainlist.com (Liberal: Blocks mostly malware. Small list)'
list[src20]='https://www.malwaredomainlist.com/hostslist'
list[file20]='hosts.txt'
list[target20]='hosts.txt'
list[ip20]='0'

list[status21]='+'
list[info21]='KADhosts (Liberal: Blocks malware hosts)'
list[src21]='https://raw.githubusercontent.com/azet12/KADhosts/master/KADhosts.txt'
list[file21]=''
list[target21]='hosts.txt'
list[ip21]='0'

list[status22]='+'
list[info22]='yoyo.org (Liberal: Blocks adservers)'
list[src22]='https://pgl.yoyo.org/as/serverlist.php?showintro=0;hostformat=hosts'
list[file22]=''
list[target22]='hosts.txt'
list[ip22]='0'

list[status23]='+'
list[info23]='Mitchell Krog (Liberal: Blocks spam bot hosts)'
list[src23]='https://raw.githubusercontent.com/mitchellkrogza/Badd-Boyz-Hosts/master/hosts'
list[file23]=''
list[target23]='hosts.txt'
list[ip23]='0'

list[status24]='+'
list[info24]='CoinBlockerLists (Liberal: Blocks cryptominers)'
list[src24]='https://zerodot1.gitlab.io/CoinBlockerLists/hosts_browser'
list[file24]=''
list[target24]='hosts.txt'
list[ip24]='0'

list[status25]='+'
list[info25]='Developer Dan Ads and Trackers Safe List (Liberal: Blocks ads and trackers)'
list[src25]='https://www.github.developerdan.com/hosts/lists'
list[file25]='ads-and-tracking-extended.txt'
list[target25]='hosts.txt'
list[ip25]='0'

list[status26]='+'
list[info26]='Developer Dan Ads and Trackers Aggressive List (Moderate: Could cause browsing issues)'
list[src26]='https://www.github.developerdan.com/hosts/lists'
list[file26]='tracking-aggressive-extended.txt'
list[target26]='hosts.txt'
list[ip26]='0'

# Alternative address: https://raw.githubusercontent.com/AdAway/adaway.github.io/master/hosts.txt
list[status27]='+'
list[info27]='AdAway (Liberal: Blocks ad networks)'
list[src27]='https://adaway.org'
list[file27]='hosts.txt'
list[target27]='hosts.txt'
list[ip27]='0'

list[status28]='+'
list[info28]='hostsfile.org (Very Strict: Regular blocks + porn, gambling and gaming sites)\n'
list[src28]='https://www.hostsfile.org/Downloads'
list[file28]='hosts.txt'
list[target28]='hosts.txt'
list[ip28]='0'

# Others

list[status29]='+'
list[info29]='Community Whitelist (Host Flash™ whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src29]='https://gist.githubusercontent.com/VR51/7eaace2b6778ea508996/raw'
list[file29]=''
list[target29]='whitelist.txt'
list[ip29]='0'

list[status30]='+'
list[info30]='Community Whitelist Wild (Host Flash™ wild whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src30]='https://gist.githubusercontent.com/VR51/9798c78337fe2f7ad589/raw/'
list[file30]=''
list[target30]='whitelist-wild.txt'
list[ip30]='0'

list[status31]='+'
list[info31]='Community Blacklist (Host Flash™ blacklist. Blocks a limited set of sites not blocked by other lists)'
list[src31]='https://gist.githubusercontent.com/VR51/ef3b90b1be2693a44f27/raw/'
list[file31]=''
list[target31]='hosts.txt'
list[ip31]='1'

list[status32]='+'
list[info32]='Local Whitelist (Your own custom whitelist)'
list[src32]='localhost'
list[file32]="${file[confwl]}"
list[target32]='whitelist.txt'
list[ip32]='0'

list[status33]='+'
list[info33]='Local Whitelist Wild (Your own custom wild whitelist)'
list[src33]='localhost'
list[file33]="${file[confwlw]}"
list[target33]='whitelist-wild.txt'
list[ip33]='0'

list[status34]='+'
list[info34]='Local blacklist (Your own custom blacklist)'
list[src34]='localhost'
list[file34]="${file[confbl]}"
list[target34]='hosts.txt'
list[ip34]='1'

# GENERAL

essentialpackages=( zip unzip 7z curl sed git )
	
conf[ess]=0 # Essentials # Install build essential software. 0 = Not done, 1 = Done
conf[upv]=0 # Update Host Flash™ program.
#conf[locv]=$($binary -v) # Installed package version
conf[inst]=$( ls -l "$0" | cut -d' ' -f 6-8) # $package installation date
conf[locv]="$version installed ${conf[inst]}"
conf[gitv]=$(curl -v --silent "${rem[gith]}/commit/master" --stderr - | grep '<relative-time datetime' | sed -E 's#.+">(.+)<.+#\1#')
	networked="$?" # Are we connected to the net? We are if $networked = 0.
conf[hosts]=$( ls -l "${file[hosts]}" | cut -d' ' -f5 ) # Hosts file size
conf[hostt]=$( ls -l "${file[hosts]}" | cut -d' ' -f 6-8 ) # Hosts file timestamp
conf[hostc]=$( wc -l "${file[hosts]}" | cut -d' ' -f1 ) # Hosts file line count

conf[ip]='0.0.0.0' # Redirect IP address
conf[mode]='1' # Build Only or Build and Install 0 or 1

timestamp="$(date +"%Y-%m-%d-%H-%M-%S")"

# LOGS
# Partially utilised. Usage to be expanded
# Log host file history, general log messages and debug messages
function __log() {
	# @1 = File to store log
	# @2 = Message to store with log
	
	file=$1
	message=$2
	
	now="$(date +"%Y-%m-%d %H:%M:%S")"
	
	case "$file" in
		hist)
			if test "$message" ; then echo "$message" >> "${file[hist]}"; fi
			echo "$now: Line Count: ${conf[hostc]} | Bytes: ${conf[hosts]} | Timestamp: ${conf[hostt]} | Location: ${file[hosts]}" >> "${file[hist]}"
		;;
		log)
			echo "$now: $message" >> "${file[log]}"
		;;
		debug)
			echo "$now: $message" >> "${file[debug]}"
		;;
	esac

}

## END CONFIGS

## BEGIN

# Other settings
bold=$(tput bold)
normal=$(tput sgr0)

# Locate where we are
filepath="$( echo $PWD )"

# A Little precaution
cd "$filepath"

# Make/Remove directories and files

function __download_tlds() {
	if test $(find "${file[conftld]}" -mmin +1440) || test ! -f "${file[conftld]}" # If exists but is older than 1440 minutes
	then
		curl -e -L "${rem[tld]}" "${rem[tld]}" -o "${file[conftld]}"
		sed -e 's/\(.*\)/\L\1/' "${file[conftld]}" > "${file[conftld]}tmp"
		grep -vE '^#' "${file[conftld]}tmp" > "${file[conftld]}"
		# Next lines allow the file to be passed to Grep as a string of ORs
		#grep -vE '^#' "${file[conftld]}tmp" | tr '[:space:]' '|' > "${file[conftld]}"
		#sed -i 's/[|]$//' "${file[conftld]}" # Remove superfluous | from end of file
		#rm "${file[conftld]}tmp"
	fi
}
# __download_tlds # Get TLD list # Not yet used.

case "${debug}" in
	0)
		if test -d "${dir[tmp]}"; then
			rm -r "${dir[tmp]}" # Clean the tmp directory but not if we are debugging.
		fi
	;;
esac

# Make directories and files that do not yet exist
mkdir -p "${dir[@]}" # Make directories
touch -a "${file[@]}" # Make config files

# INSTALL RC SETTINGS

function __repaint() {
# Loads configs then clears the screen
# Whatever calls this should reload the screen for the new configs to be reflected on the screen

	# @1 = type: soft, hard, conf, ret
	#  soft just refreshes the screen
	#  hard reloads the script in the current shell
	#  conf must be followed by a config file to load. Loads default conf then extra conf.
	#  'no argument' loads the default config file represented by ${file[conf]}
	# @2..@n = config file(s) to reload
	#
	# ret executes the function stated in $2
	#
	# We use $in instead of $@
	
	__clear
	
		in=( $@ )
	
	case ${in[0]} in
	
		soft) # Reset variables
			unset
			__repaint
	
		;;
		
		hard) # Restart this script
			exec bash "$0"
		
		;;

		conf) # Include basic conf and any extras listed in $@

			for i in ${in[@]:1}; do
				__flying_sourcer "$i"
			done
			__flying_sourcer "${file[conf]}"
		
		;;
		
		ret)
			$2
		
		;;

		*) # Include basic conf only

		__flying_sourcer "${file[conf]}"
		
		;;
	
	esac

}


# Include custom lists

__repaint conf "${file[confcl]}"

##
# Actions
##

function __run() {
	# Check for terminal then run else just run program
	
	tty -s
	if test "$?" -ne 0 ; then
		__launch
	else
		__menu_main "${1:-}" # This will be changed when CLI added
	fi

}

function __hosts_update() {
	# Read the file of hosts and remove any line listed in the input whitelist file
	# The results are logged in a file in the config directory.

	# @1 = type: (file) norm or wild, or (string) rem or remw
	# @2 = file to remove data from
	# @3 = file containing lines of data to remove from @2 or single line of text to remove from @2
	
	f2="$2"
	f3="$3"

	ip=$(echo "${conf[ip]}" | sed 's/\./[.]/g') # Convert periods to character group (just commenting out sometimes failed)
	
	case $1 in
		norm)
			# We tried a method that removed the while loop. It was overzealous so reverted back to while loop.
			echo -ne "\n###\n# NON-WILD WHITELIST\n###\n\n" >> "${file[confr]}"

			while read LINE ; do
				LINE=$(echo $LINE | sed 's/\./[.]/g')
				echo -ne  "\n# $LINE\n\n" >> "${file[confr]}"
				grep -i "^${ip}[[:blank:]]${LINE}"'$' "${f2}" >> "${file[confr]}" # List of hosts removed during whitelisting
				grep -vi "^${ip}[[:blank:]]${LINE}"'$' "${f2}" > "${f2}.tmp" # This method removes whitelisted hostnames
				mv -f "${f2}.tmp" "${f2}"
			done < "${f3}"

		;;

		wild)

			# Process wild whitelist to replace .TLD with all possible TLD values
			# Testing - will eventually allow for .TLD in wild whitelist to represent any valid TLD.
			# Disabled for now because it causes grep to crash while whitelisting -- too many arguments.
			#while read LINE ; do
			#	sed -r "s/^(.*)[.]TLD/\1.${LINE}/g" "$3" >> "${dir[tmp]}/wlwtmp" # Replace 'TLD' with list of possible TLDs
			#	echo '' >> "${dir[tmp]}/wlwtmp"
			#done < "${file[conftld]}"

			#grep -v "[.]TLD" "$3" >> "${dir[tmp]}/wlwtmp" # Add none .TLD$ lines back into the wild list

			echo -ne "\n###\n# WILD WHITELIST PASS 2 - WILD\n###\n\n" >> "${file[confr]}"

			while read LINE ; do
				LINE=$(echo $LINE | sed 's/\./[.]/g') # Replace periods with character group match to prevent periods being interpreted as 'any character'
				echo -ne  "\n# $LINE\n\n" >> "${file[confr]}"
				grep -i "^${ip}[[:blank:]].*[.]${LINE}" "${f2}" >> "${file[confr]}" # List of hosts removed during whitelisting
				grep -vi "^${ip}[[:blank:]].*[.]${LINE}" "${f2}" > "${f2}.tmp" # This method removes whitelisted hostnames
				mv -f "${f2}.tmp" "${f2}"
			done < "${f3}"

		;;

		linen) # Not yet used
		
			data=$3
			data=$(echo $data | sed 's/\./[.]/g') # Replace periods with character group to prevent them being interpreted as 'any character'
			# sed -r -i "s/${ip}[[:blank:]]$3.*?$//g" "$2" # Remove exact match
			grep -i "^${ip}[[:blank:]]${data}"'$' "$2" >> "${file[confr]}" # List of hosts removed during whitelisting
			grep -vi "^${ip}[[:blank:]]${data}"'$' "$2" > "$2.tmp" # This method removes whitelisted hostnames
			mv -f "$2.tmp" "$2"

		;;

		linew) # Not yet used
			data=$3
			data=$(echo $data | sed 's/\./[.]/g') # Replace periods with character group to prevent them being interpreted as 'any character'
			# sed -r -i "s/${ip}[[:blank:]].*\.$3.*?$//g" "$2" # Remove any line with a match
			grep -i "^${ip}[[:blank:]].*[.]${data}" "$2" >> "${file[confr]}" # List of hosts removed during whitelisting
			grep -vi "^${ip}[[:blank:]].*[.]${data}" "$2" > "$2.tmp" # This method removes whitelisted hostnames
			mv -f "$2.tmp" "$2"

		;;

	esac

}

function __conf_update() {
	# Add or remove a single host from the .hf*rc config files
	# ! Considered merging this function with __hosts_update. Opted to keep the two separate. It simplifies input sanitization (to come later).

	# @1 = type: add, rem, remw, or remn (remove by line number)
	# @2 = data to add/remove
	# @3 = file to add/remove @1 to/from

	d=$2
	f=$3

	case $1 in

		add)
			grep "${d}" "${f}"
			if test $? -eq 1
			then
				echo "${d}" >> "${f}"
			fi
		;;

		rem)
			sed -r -i "s/${d}.*?$//g" "${f}" # Remove exact match
			sed -i '/^$/d' "${f}" # Remove empty lines
		;;

		remw)
			sed -r -i "s/.*?${d}.*?$//g" "${f}" # Remove any line with a match
			sed -i '/^$/d' "${f}" # Remove empty lines
		;;

		remn)
			if [ $d != '' ]; then
				sed -i "${d}d" "${f}" # Remove the line number $d from the file
				sed -i '/^$/d' "${f}" # Remove empty lines
			fi
		;;
	esac
	
}

function __conf_delete() {
	__repaint conf "${file[confcl]}"
	
	# Delete specified file
	# @1 = File to delete
	# @2 = File's friendly name

	f[1]=${1}
	f[2]=${2}

	printf "${bold}DELETE CONFIG FILES${normal}"
	printf "\n\nReset chosen configuration file\n\n"

	# Display menu
	unset menu
	menu[1]="Proceed: Reset ${f[2]} by deleting file ${f[1]}"
	menu[2]="Return: Do not reset ${f[2]}"

	m=1
	while [ $m -le ${#menu[@]} ] ; do
		printf "$m) ${menu[$m]}\n"
		let m=m+1
	done
	
	printf "\nChoose an option then press Enter:\n"
	read a
	
	while true ; do
		case $a in
			1)
				if test -f "${f[1]}"; then
					rm "${f[1]}"
					printf "${f[2]} reset.\n"
					printf "\nPress any key to continue\n"
					touch "${f[1]}"
					read something
				else
					printf "${f[2]} custom settings not yet created. Nothing to do. Nothing done.\n"
					printf "\nPress any key to continue\n"
					read something
				fi
				__menu_reset_confs
			;;
			
			2)
				__menu_reset_confs
			;;
			
			*)
				__repaint
			;;
		esac
	done

}

function __remove_custom_list_entry_menu() {
	filename=$1
	description=$2

	printf "Custom $description is located at $filename\n\n"
	__display_file $filename
	printf "\nType the line number to remove then press Enter. Press 0 to exit:\n\n"
	read a

	case $a in
		0)
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;

		*)
			__conf_update 'remn' "$a" "$filename"
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;
	esac
}

function __display_file() {
	filename=$1

	n=1
	while read LINE; do
		printf "$n) $LINE\n"
		let n=n+1
	done < $filename
}

function __status() {
	# Change status of list: On or Off.
	
	# @1 = host list to change status of
	
	n=$1
	if grep "list\[status${n}]='-'" "${file[conf]}"
	then
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='+'" >> "${file[conf]}"
	else
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='-'" >> "${file[conf]}"
	fi
	
}

function __build() {
	# Build the hosts file: download lists, clean them, merge them, create new hosts file

	# Download lists. Merge them into new hosts file
	n=1
	until [ $n -eq 0 ]; do

		status="${list[status${n}]}"
		info="${list[info${n}]}"
		src="${list[src${n}]}"
		file="${list[file${n}]}"
		target="${list[target${n}]}"
		ip="${list[ip${n}]}"

		if test "$status" = '+' # The list is enabled
		then

			case "$src" in

				localhost)

					case "$target" in
						whitelist-wild.txt)
							cat "$file" >> "${dir[tmpu]}/whitelist-wild.txt"
						;;
						
						whitelist.txt)
							cat "$file" >> "${dir[tmpu]}/whitelist.txt"
						;;
						
						*) # Is a hosts.txt file
							cat "$file" >> "${dir[tmpu]}/hosts.txt.$n"
						;;
					esac
					
				;;

				*)

					# Grab source hosts file from its remote location
					if test "${file}"
					then
						# log
						if test $debug -ne '0' ; then
							result=$(curl -LI --silent -e "$src" "$src/$file")
							__log debug "$result"
						fi
						# download
						curl -L -e "$src" "$src/$file" -o "${dir[tmpd]}/$file"
					else
						# log
						if test $debug -ne '0' ; then
							result=$(curl -LI --silent -e "$src" "$src")
							__log debug "$result"
						fi
						# download
						file="nofile.txt.$n"
						curl -L -e "$src" "$src" -o "${dir[tmpd]}/$file"
					fi

					# Filter by type
					case "$target" in

						whitelist-wild.txt)
							cat "${dir[tmpd]}/$target" >> "${dir[tmpu]}/whitelist-wild.txt"
							rm "${dir[tmpd]}/$target"
						;;
						
						whitelist.txt)
							cat "${dir[tmpd]}/$target" >> "${dir[tmpu]}/whitelist.txt"
							rm "${dir[tmpd]}/$target"
						;;
						
						*) # $target is a source hosts file
							# Doing this back-to-front so we do not need to test text mime types
							# Attempt to extract package content
							# If a package is found it contains the target file
							unzip -o "${dir[tmpd]}/$file" -d "${dir[tmpd]}" > /dev/null 2>&1 # Try unzip. Suppress errors
							if test $? -eq 0
							then
								mv "${dir[tmpd]}/$target" "${dir[tmpu]}/hosts.txt.$n"
								rm "${dir[tmpd]}/$file"
							else # If unzip failed try 7z
								7z e -y "${dir[tmpd]}/$file" -o"${dir[tmpd]}" # Try 7z. Suppress errors
								if test $? -eq 0
								then
									mv "${dir[tmpd]}/$target" "${dir[tmpu]}/hosts.txt.$n"
									rm "${dir[tmpd]}/$file"
								else # It's not a package file so treat as a txt file: just move and rename
									mv "${dir[tmpd]}/$file" "${dir[tmpu]}/hosts.txt.$n"
								fi
							fi
						;;
					
					esac

				;;

			esac

			# Add IP address prefix if required
			case "${ip}" in

				1)
					sed -r -i "s/^/${conf[ip]} /g" "${dir[tmpu]}/$target.$n" # Loopback IP
				;;

			esac

		fi

		credits+=("# Includes hosts blacklist from $info\n")

		if test ${#status} -eq 0
		then
			c=$n
			let c=c-1
			let n=n-n
		else
			let n=n+1
		fi

	done

	# Merge files. We do it this way to simplify debugging
	until [ $c -eq 0 ]; do

		echo "File: $c" >> "${dir[tmp]}/merge-counter.txt"

		if test -f "${dir[tmpu]}/hosts.txt.$c"
		then
			cat "${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmpu]}/hosts-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmp]}/merge-counter.txt" # Log the merge
				mv -f "${dir[tmpu]}/hosts.txt.$c" "${dir[tmpp]}/hosts.txt.$c" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmp]}/merge-counter.txt" # Log the merge
			fi
		fi

		# No need to number whitelist files. We know what we are dealing with here so we use the same file throughout.
		if test -f "${dir[tmpu]}/whitelist.txt"
		then
			cat "${dir[tmpu]}/whitelist.txt" >> "${dir[tmpu]}/whitelist-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/whitelist.txt" >> "${dir[tmp]}/merge-counter.txt"
				cp "${dir[tmpu]}/whitelist.txt" "${dir[tmpp]}/whitelist.txt" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/whitelist.txt" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi

		if test -f "${dir[tmpu]}/whitelist-wild.txt"
		then
			cat "${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmpu]}/whitelist-wild-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmp]}/merge-counter.txt"
				cp "${dir[tmpu]}/whitelist-wild.txt" "${dir[tmpp]}/whitelist-wild.txt" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi
		
		let c=c-1
		
	done

	__repaint

	printf "This next part could take some time.\nLook in ${dir[tmpu]} to view activity in realtime.\n\nProcessing...\n"

	# Convert non-UTF8 characters to UTF8 to fix characters in French lists.
	# Throw away anything that does not begin with an IP4 address.
	# We alternate file name between hosts-temp.txt and hosts-temp-copy.txt as we work on them.

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/whitelist-temp.txt" > "${dir[tmpu]}/whitelist-temp-copy.txt"
	sed '/^$/d' "${dir[tmpu]}/whitelist-temp-copy.txt" > "${dir[tmpu]}/whitelist-temp.txt"
	rm "${dir[tmpu]}/whitelist-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/whitelist-wild-temp.txt" > "${dir[tmpu]}/whitelist-wild-temp-copy.txt"
	sed '/^$/d' "${dir[tmpu]}/whitelist-wild-temp-copy.txt" > "${dir[tmpu]}/whitelist-wild-temp.txt"
	rm "${dir[tmpu]}/whitelist-wild-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/hosts-temp.txt" > "${dir[tmpu]}/hosts-temp-copy.txt"
	rm "${dir[tmpu]}/hosts-temp.txt"

	#	Format raw list data in hosts-temp.txt
	sed -r -i 's/[[:blank:]]+/ /g' "${dir[tmpu]}/hosts-temp-copy.txt" # Convert all spaces and tabs to a single space
	grep -Ev "[[:blank:]](ip6-)?(localhost|loopback|localnet|mcastprefix|allnodes|allrouters)\s?\b" "${dir[tmpu]}/hosts-temp-copy.txt" > "${dir[tmpu]}/hosts-temp.txt" # Remove localhost lines - the computer's installed host file already has localhost defined the way it should be
	grep -E '^[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?' "${dir[tmpu]}/hosts-temp.txt" > "${dir[tmpu]}/hosts-temp-copy.txt" # Extract and keep only lines that begin with an IP address
	sed -r -i "s/^[012][\.01-9]{1,2}+[[:blank:]]/${conf[ip]} /g" "${dir[tmpu]}/hosts-temp-copy.txt" # Replace with a single space and the new IP address everything up to, and including, the first tab in each line

	# Sort the lists
	if test -f "${dir[tmpu]}/hosts-temp-copy.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/hosts-temp-copy.txt" # Standardise line endings
		sort -f -u "${dir[tmpu]}/hosts-temp-copy.txt" > "${dir[tmpu]}/hosts-temp.txt"
		rm "${dir[tmpu]}/hosts-temp-copy.txt"
	fi

	if test -f "${dir[tmpu]}/whitelist-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/whitelist-temp.txt" # Fix line endings
		sort -f -u "${dir[tmpu]}/whitelist-temp.txt" > "${dir[tmpu]}/whitelist.txt"
		rm "${dir[tmpu]}/whitelist-temp.txt"
	fi

	if test -f "${dir[tmpu]}/whitelist-wild-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/whitelist-wild-temp.txt" # Fix line endings
		sort -f -u "${dir[tmpu]}/whitelist-wild-temp.txt" > "${dir[tmpu]}/whitelist-wild.txt"
		rm "${dir[tmpu]}/whitelist-wild-temp.txt"
	fi

	# Process whitelist -- remove whitelisted domains from hosts-temp.txt
	# Always pass wild through norm too
	__hosts_update "norm" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist.txt"
	__hosts_update "norm" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist-wild.txt"
	__hosts_update "wild" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist-wild.txt"
	
	# hosts.txt should not exist at this point
	if test -f "${dir[tmpu]}/hosts.txt"
	then
		rm "${dir[tmpu]}/hosts.txt"
	fi

	# Get head of the existing hosts file stored at /etc/hosts
	# Remove old Host Flash™ blacklist from existing hosts file, assuming blacklist exists
	# Remove empty lines from the end of the header
	# This creates file hosts.head which is used a few lines down from here

	if grep -zPo '# Host.? Flash' "${file[hosts]}"
	then
		grep -zPo '(?s).*# Host.? Flash' "${file[hosts]}" | head -n -1 | grep -v '^[[:space:]]$' > "${dir[tmpu]}/hosts.head" # Remove old HF data, remove HF header remove empty lines.
	else
		cp "${file[hosts]}" "${dir[tmpu]}/hosts.head" # No existing hostsfile so just copy hosts to hosts.head
	fi

	printf '\n\n# Host Flash™ Firewall\n\n# Credits\n\n' >> "${dir[tmpu]}/hosts.head" # Add HF heading

	for i in "${credits[@]}" ; do
		printf "$i" >> "${dir[tmpu]}/hosts.head" # Add HF list provider credits
	done

	printf "\n\n# Installed with $package\n\n# Visit host-flash.com to learn more\n\n" >> "${dir[tmpu]}/hosts.head" # Add HF credit

	cat "${dir[tmpu]}/hosts.head" "${dir[tmpu]}/hosts-temp.txt" > "${dir[src]}/hosts.txt" # Merge the old head with the new hosts blacklist

}

function __enable() {
	# Install Host Flash™ hosts list to /etc/hosts

	echo
	# Get su authority
	sudo -v

	# Backup original hosts file before first ever use of Host Flash™ in this system.
	# Only happens if the backup does not yet exist.
	# Copies the file to dir[bck] and the system's defaults hosts file directory. This makes the file more obvious to locate.
	if test ! -f "${file[hosts]}.hf.original"
	then
		sudo cp "${file[hosts]}" "${file[hosts]}.hf.original"
		zip "${dir[bck]}/hosts.original" "${file[hosts]}.hf.original"
		__log hist # Add hosts file information to file[hist]
	fi
	# Legacy. For versions of HF < 4
	if test ! -f "${dir[bck]}/hosts.original.zip"
	then
		if test -f "${file[hosts]}.hf.original"
		then
			cp "${file[hosts]}.hf.original" "${dir[bck]}/hosts.original"
			__log hist # Add hosts file information to file[hist]
		fi
	fi

	# Install. Backup the current file then install the new one.
	if test -f "${dir[src]}/hosts.txt"
	then
		zip "${dir[bck]}/hosts-$timestamp" "${file[hosts]}" # General restore file
		sudo mv -f "${dir[src]}/hosts.txt" "${file[hosts]}" # New hosts file
		__log hist # Add hosts file information to file[hist]
	else
		message[enable]="$package hosts file not found. Have you built it yet?"
	fi

	# Help the new hosts file take effect.
	__cleandns
	
	sudo -k

}

function __disable() {
	# Remove Host Flash™ hosts list from /etc/hosts

	echo
	# Get su authority
	sudo -v
	
	cp "${file[hosts]}" "${dir[tmp]}/hosts.copy"
	if grep -zPo '# Host.? Flash' "${dir[tmp]}/hosts.copy"
	then
		# Remove old HF data, remove HF header remove empty lines.
		grep -zPo '(?s).*# Host.? Flash' "${dir[tmp]}/hosts.copy" | head -n -1 | grep -v '^[[:space:]]$' > "${dir[tmp]}/hosts.head"
		sudo mv -f "${dir[tmp]}/hosts.head" "${file[hosts]}"
	else
		message[disable]="$package not installed. Nothing to do."
	fi

	# Help the new hosts file take effect.
	__cleandns
	
	sudo -k

}

function __cleandns() {
	# Clean the DNS local servers. We try them all.. just in case.

	flush=(
	'systemd-resolve --flush-caches' # General
	'service network-manager restart' # Debian
	'systemctl restart network.service' # Systemd
	'systemctl restart wicd.service' #  Systemd for WICD
	'systemctl restart NetworkManager.service' # Fedora, Manjaro, Arch using Network Manager
	'service nscd restart' # FreeBSD
	'/etc/init.d/network restart' # RHEL/Centos'
	'/etc/init.d/dns-clean restart' # Mint'
	'/etc/init.d/nscd restart' # other
	'/etc/init.d/networking force-reload' # Other
	'/etc/init.d/dnsmasq restart' # Other
	)
	
	sudo -v

	for i in "${flush[@]}"; do
		printf "${bold}Attempting to flush DNS cache ${normal} using command: $i\n"
		sudo $i
		printf "Do not worry if the above says 'fail'. We only need one success.\n\n"
	done
	
	sudo -k

}

##
# MENUS
##

# Main Menu

function __menu_main() {

	__repaint conf "${file[confcl]}"

	# $1 = instruction

	while true; do

		if test "$?" -eq 0
		then

			case "${conf[mode]}" in

				0)
					mode[0]='MODE: Build Hosts Firewall Only\n'

				;;

				1)
					mode[0]='MODE: Build and Install Hosts Firewall\n'

				;;

			esac

			# Set Menu Options

			unset menu
			menu[1]='List Management (enable or disable repositories)'
			menu[2]='Custom List Management (add or remove whitelist/blacklist rules)\n'

			menu[3]="[${conf[ip]}] - Change redirect IP address\n"

			menu[4]='Change Build/Install Mode\n'

			case "${conf[mode]}" in

				0)
					menu[5]='Build Host Flash™ list but do not install.\n'

				;;

				1)
					menu[5]='Build and Install Host Flash™ list.\n'

				;;

			esac

			menu[6]='Enable Host Flash™ list.'
			menu[7]='Disable Host Flash™ list.'
			case "${conf[mode]}" in

				0)
					menu[8]='Update hosts file with new custom rules but do not enable new hosts file\n'

				;;

				1)
					menu[8]='Update and Enable hosts file with new custom rules\n'

				;;

			esac
			menu[9]='Flush DNS rules\n'

			menu[10]='Restore original hosts file.\n'

			menu[11]="Reset $package configs and files (select in next menu)"

			case "${conf[ess]}" in

				0)
					menu[1000]='Install missing software packages needed by Host Flash™\n'

				;;

			esac

			printf $bold
			printf "${mode[0]}\n"
			printf $normal

			printf "MENU\n\n"

			n=1
			for i in "${menu[@]}"; do
				if [ "$i" == '' ]; then
					printf "\n"
				else
					printf "$n) $i\n"
					select[$n]=$n
					let n=n+1
				fi
			done

			printf "\nR) Restart $package\n"
			printf "\n0) Exit\n\n"

			# Instructions
			
			printf "INSTRUCTIONS: a) Select lists to install with option 1, b) optionally add custom domains to blacklist or whitelist, c) build the hosts file firewall with option 5, before you d) Enable the newly built hosts file firewall with option 6. Change MODE to 'Build and Install' to set $package to automatically install the hosts file after it is built. $package will only work if the Essential Software is installed.\n\n"
			
			# Notices

			printf $bold

			printf "\nGENERAL INFO\n"
				
			printf $normal

			printf "\n System $package: ${conf[locv]}"
			printf "\n Latest git commit: ${conf[gitv]}\n"
			printf "\n Hosts File Info: Line Count: ${conf[hostc]} | Bytes: ${conf[hosts]} | Timestamp: ${conf[hostt]} | Location: ${bold}${file[hosts]}${normal}\n"
			
			printf "\nIf the computer crashes during installation lower the number of lists processed or cool your computer then try again.\n"

			printf $bold
				printf "\nChoose Wisely: "
			printf $normal
			read REPLY
		
		else
			REPLY=$1
		fi

		case $REPLY in

		1) # Choose lists to download # When moved to its own menu this will only be [[:num:]]
			__menu_list_management

		;;
		
		2) # Manage custom whitelists and blacklists
			__menu_custom_list_management
			
		;;

		3) # Change redirect IP address

			printf "Current Redirect IP: ${conf[ip]}"
			printf "\nType in new Redirect IP then press Enter:\n\n"
			read ip

			if grep "conf\[ip]=" "${file[conf]}"
			then
				sed -i "s/conf\[ip]='.*'/conf\[ip]='$ip'/g" "${file[conf]}"
			else
				echo -e "conf""[ip]='$ip'" >> "${file[conf]}"
			fi

			__repaint

		;;

		4) # Set Mode

			if grep "conf\[mode]='0'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='0'/conf\[mode]='1'/g" "${file[conf]}"
				
			elif grep "conf\[mode]='1'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='1'/conf\[mode]='0'/g" "${file[conf]}"
				
			else
				echo -e "conf""[mode]='1'" >> "${file[conf]}"
			fi

			__repaint

		;;

		5) # Build or Build and Install the Host Flash™ hosts file

			__build
			
			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;

		6) # Enable Host Flash™ hosts list

			__enable
			__repaint

		;;

		7) # Disable Host Flash™ hosts list

			__disable
			
			if test "${message[disable]}"
			then
				printf "\n${message[disable]}\nPress any key."
				read -a
			fi

			__repaint

		;;

		8) # Update hosts file with new custom rules

			__clear

			printf "This next part could take some time.\nLook in ${dir[tmp]} to view activity in realtime.\n\nProcessing...\n"

			cp "${file[hosts]}" "${dir[tmp]}/hosts-temp.txt"
			cat "${dir[tmp]}/hosts-temp.txt" "${file[confbl]}" >> "${dir[tmp]}/hosts.txt"
			
			# Always pass wild through norm too
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwl]}"
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"
			__hosts_update "wild" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"

			mv -f "${dir[tmp]}/hosts.txt" "${dir[src]}/hosts.txt"

			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;
		
		9)
			__clear
			__cleandns
			printf "\nPress any key"
			read a
			__repaint
		
		;;

		10) # Restore original hosts list

			if test -f "${file[hosts]}.hf.original"
			then # Restore the backup head from the original hosts file
				sudo mv -f "${file[hosts]}.hf.original" "${file[hosts]}"
			fi

			__repaint

		;;

		11) # Reset Custom Configs

			__menu_reset_confs

			__repaint hard

		;;

		12) # Install software packages necessary to build the package

			case "${conf[ess]}" in
			
				0)

					printf "\nThis will attempt to install the following packages:\n"

					for i in "${essentialpackages[@]}"; do
						printf "$i "
					done

					printf "\nContinue to install them: Yn:\n"
					read a
					
					let n=1
					while true; do
						case $a in

						y|Y)
						
							case $n in
							1)
								echo -e "conf""[ess]='1'" >> "${file[conf]}"
								sudo apt-get update
								let n=n+1
							;;
							esac
							
							for i in "${essentialpackages[@]}"; do
								sudo apt-get build-dep -y -q $i
								sudo apt-get install -y -q --install-suggests $i
							done

							printf "\nPress any key to continue\n"
							read something
							__repaint

						;;

						n|N)

							__repaint

						;;
						
						*)

						esac
						
					done
					
				;;
				
			esac

		;;
		
		[Rr])
			__repaint hard
		;;

		0) # Exit

			exit 0

		;;

		*)

		esac

	done

}


# Sub Menus

function __menu_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"
		
		# Display lists available
		# $listsc # Value discovered during list array auto declares (see above)
		
		n=1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter list number to enable [+] or disable [-] then press Enter.\n"
		printf "\nType ${bold}E${normal} to Add, Remove or Edit remote hosts list providers.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			[Ee])
				__menu_remote_list_management

			;;

			*)
				__status $a
				__repaint conf "${file[confcl]}"
			;;

		esac

	done
}

function __menu_remote_list_management() {
	# Add or Remove new remote list providers

	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT: CUSTOM REMOTE SOURCES${normal}"
		printf "\n\nCustom remote list resources\n\n"
		
		# Display custom remote lists available for management
		# $listsc # Value discovered during list array auto declares (see above)

		let n=$listc+1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done

		printf "\n${bold}A${normal}) to Add a custom remote hosts list provider\n"
		printf "${bold}D${normal}) to Delete a custom remote hosts list provider\n"
		printf "${bold}E${normal}) to Edit a custom remote hosts list provider\n"
		printf "\n0) Return to Main Menu\n"

		read a

		case $a in

			0)
				__menu_main
			;;

			[Aa])

				__clear

				printf "\nEnter details for new resource list ${n}.\n\n"
				
				__conf_update 'add' "list[status${n}]='+'" "${file[confcl]}"

				printf "Enter brief list description: "
				read a
				__conf_update 'add' "list[info${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the download URL e.g https://example.com/download-page.\nDo not include the package/file name or a trailing slash: "
				read a
				__conf_update 'add' "list[src${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package name: "
				read a
				__conf_update 'add' "list[file${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package type e.g unzip, p7zip, direct or raw: "
				read a
				__conf_update 'add' "list[flag${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the target file name that contains the hosts data: "
				read a
				__conf_update 'add' "list[target${n}]='${a}'" "${file[confcl]}"

				printf "\nDo all hostnames in this list need an IP address prefix? (1 for Yes, 0 for No): "
				read a
				__conf_update 'add' "list[ip${n}]='${a}'" "${file[confcl]}"

				printf "\nList ${n} added to hosts file repository. $package will restart after you press Enter.\n"
				read a
				
				__repaint hard

			;;

			[Dd])

				printf "\nEnter list number to delete.\n"
				read a

				__conf_update 'remw' "${a}]" "${file[confcl]}"

				printf "\nList ${a} deleted from hosts file repository. $package will restart after you press Enter.\n"
				read a

				__repaint hard
				
			;;

			[Ee])
				# To be implemented
					__repaint hard
			;;

			*)

			;;

		esac

	done
}

function __menu_custom_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}CUSTOM LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"

		# Display custom list options
		unset menu
		menu[1]="Add a host to custom whitelist"
		menu[2]="Add a host to custom wild whitelist"
		menu[3]="Add a host to custom blacklist\n"
		menu[4]="Remove a host from custom whitelist"
		menu[5]="Remove a host from custom wild whitelist"
		menu[6]="Remove a host from custom blacklist\n"
		menu[7]="Display custom whitelist"
		menu[8]="Display custom wild whitelist"
		menu[9]="Display custom blacklist"

		n=1
		for i in "${menu[@]}" ; do
			printf "$n) ${i}\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter option number then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Add to custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a
				
				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			2) # Add to custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwlw]}" # Add host to wild whitelist
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			3) # Add to custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confbl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			4) # Remove from custom whitelist

				__remove_custom_list_entry_menu ${file[confwl]} "whitelist"

			;;

			5) # Remove from custom wild whitelist

				__remove_custom_list_entry_menu ${file[confwlw]} "wild whitelist"

			;;

			6) # Remove from custom blacklist

				__remove_custom_list_entry_menu ${file[confbl]} "blacklist"

			;;

			7) # Display custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				cat "${file[confwl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			8) # Display custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				cat "${file[confwlw]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			9) # Display custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				cat "${file[confbl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			*)


			;;

		esac

	done
}

function __menu_reset_confs() {

	__repaint conf "${file[confcl]}"

	while true; do

		printf "${bold}CUSTOM CONFS MANAGEMENT${normal}"
		printf "\n\nReset custom lists and configurations\n\n"

		# Display menu
		unset menu
		menu[1]="Reset general configurations to their default values"
		menu[2]="Delete custom host file repository lists"
		menu[3]="Delete custom whitelist"
		menu[4]="Delete custom whitelist wild"
		menu[5]="Delete custom blacklist"
		menu[6]="Delete log of removed hosts"
		menu[7]="Delete general log"
		menu[8]="Delete debug log"

		m=1
		while [ $m -le ${#menu[@]} ] ; do
			printf "$m) ${menu[$m]}\n"
			let m=m+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter item number to action then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Reset confs[]
				__conf_delete "${file[conf]}" "$package custom configuration"

			;;

			2) # Delete custom host lists
				__conf_delete "${file[confcl]}" "Custom host file repositories"

			;;

			3) # Delete custom whitelist
				__conf_delete "${file[confwl]}" "custom whitelist"
			;;

			4) # Delete custom whitelist wild
				__conf_delete "${file[confwlw]}" "custom whitelist wild"

			;;

			5) # Delete custom blacklist
				__conf_delete "${file[confbl]}" "custom blacklist"

			;;

			6)
				__conf_delete "${file[confr]}" "removed hosts log"

			;;

			7)
				__conf_delete "${file[log]}" "removed hosts log"

			;;

			8)

			;;

			*)
				__repaint conf "${file[confcl]}"
			;;

		esac

	done

	__repaint conf "${file[confcl]}"

}

## Launch

function __launch() {
	# launch terminal

	terminal=( konsole gnome-terminal x-terminal-emulator xdg-terminal terminator urxvt rxvt Eterm aterm roxterm xfce4-terminal termite lxterminal xterm )
	for i in ${terminal[@]}; do
		if command -v $i > /dev/null 2>&1; then
			exec $i -e "$0"
			# break
		else
			printf "\nUnable to automatically determine the correct terminal program to run e.g Console or Konsole. Please run this $package from the command line.\n"
			read something
			exit 1
		fi
	done
}

## Debug Flags
# To be moved to __log() (see near top of file)
case "${debug}" in

	1)
		#exec 3>&1 4>&2
		#trap 'exec 2>&4 1>&3' 0 1 2 3
		#exec 2>&1 >> "${file[log]}"
		exec 2>> "${file[debug]}"
	;;
	
esac

## Boot
__run "$@" # Loops back to the start. The script is read by BASH then __run is run. This ensures all functions are read into memory before anything happens.

# Exit is at end of __run()

# FOR DEBUGGING

# declare -p
