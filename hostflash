#!/bin/bash
# set -euo pipefail
# set -x
IFS=$'\n\t'
###
# Host Flash™ 4.0.3
#
# Downloads hosts file rules from various sources.
# Installs hosts file rules into /etc/hosts
# Integrates Host Flash™ hosts file rules with rules that already exist in /etc/hosts
#
# For OS: Linux (Debian)
# Tested With: Ubuntu flavours
#
# Lead Author: Lee Hodson<https://github.com/vr51//>
# Contributor: skeletonkey<https://github.com/skeletonkey/>
# Donate: https://paypal.me/vr51
# Website: https://host-flash.com<https://host-flash.com>
# This Release: 23rd April 2025
# First Written: 18th Oct. 2015
# First Release: 2nd Nov. 2015
#
# Copyright Host Flash™ https://host-flash.com<https://host-flash.com>
# License: GPL3
#
# Programmer: Lee Hodson<journalxtra.com>, VR51<vr51.com>
#
# Use of this program is at your own risk
#
# INSTALLS OR UPDATES
#
# Use Host Flash™ to block access to websites (hosts), ad servers, malicious websites and time wasting websites.
# Use Host Flash™ to manage your hosts file
#
# TO RUN:
#
# Ensure the script is executable:
#
#  Right-click > properties > Executable
#
#  OR
#
#  chmod u+x hostflash
#
# Launch by clicking the script file or by typing `bash ./hostflash` at the command line.
#
# Host Flash™ will attempt to preserve existing host rules.
#
###

##
# TO DO / DEV NOTES
#	Please feel free to work through this list if you wish to help the project.
#
#
#
#
# line 1583 fix restore. should point to backup directory and unzip into tmp directory then test for hosts before moving it to /etc/hosts
##
#
# Modularisation
#		Host Flash is meant to be a single file downloadable script. 
#		I (Lee) might convert the script to an installer that chops itself up to extract modules.
#		This would enable Host Flash to accept plugins, facilitate user customizations and facilitate HF's future development.
#		TBC...
#
#	Use one file per list.
#	Download Free Mode. Place source files into directory. HF builds from source files.
#	Rebuild source file process method
#
#	If internet is available (Check exit status of latest Git commit check: $networked should = 0 if the net is available)
#		Download DOCs
#		Offer HF script updates
#	Show error if internet is unavailable
#
# versions: add deb installer
#
#  En/disable Automatic list update
#  En/disable Automatic script update
#
# CLI: disable HF, enable HF, add rule, remove rule, update lists, set options
#
# List Build Options
#  Build pure list. No whitelisting
#   Check whitelists (extracted, found, not found) # To be integrated from standalone file.
#    Rebuild whitelists after check
#  Build filtered list. Whitelisting done
#   Install after build
#   Do not install after build
# Compact local whitelists and local blacklists (all lower, sort -u)
# View/Edit local lists (nano, pico, cat)
#
# Feature: search hosts file for a domain or list of domains (grep without regex)
#  Offer to disable if found
#  Offer to add to custom whitelist
#
# Switchlist
#  Temporarily disable and enable whitelist hosts
# Options
#  Check .hfremoved list # Script written and tested ready for insertion
#   Move items from .hfremoved to post processing blacklist
#   Move items from .hfremoved to Switch List
#
# Move more actions into functions.
# Tidy up
# Add input checking/sanitisation
# Make messages and menus clearer
# Menu + View all HF configs
#
# Summary info on main screen / maybe footer for all screens
#  Add more useful info
#  Include link to host-flash.com
#
#  Info about each list
#   Last update time
#
# Go through functions to state the output format
# 
# Rebuild menu system based on SaLi text mode only
###

##
# NOTES
#
# Hosts File Build Process
#
#  The host file work is done in $HOME/src/hostflash/tmp. This eventually builds hosts.txt
#  The final build of hosts.txt is moved to $HOME/src/hostflash/
#  __enable looks for $HOME/src/hostflash/hosts.txt which it moves to /etc/hosts
#
# Whitelist Processing
#
#  Whitelist wild is processed twice:
#   As a normal whitelist
#   As a wild whitelist
#   A period is added before the first character of each host name processed
##

##
# CONFIGS ARE BELOW HERE - should be no reason to manually change these
#
# Any of these can be overruled by adding each variable along with its new value into $HOME/.config/hostflash/.hfrc
# Adding config changes to $HOME/.config/hostflash/.hfrc will protect changes from script version updates.
##

##
# Raw URLs for those who want them
# wget https://raw.githubusercontent.com/AdAway/adaway.github.io/master/hosts.txt
# wget https://adaway.org/hosts.txt
# wget https://pgl.yoyo.org/as/serverlist.php?showintro=0;hostformat=hosts
# wget https://raw.githubusercontent.com/azet12/KADhosts/master/KADhosts.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/ad_servers.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/emd.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/exp.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/fsa.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/grm.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/hfs.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/hjk.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/mmt.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/pha.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/psh.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/pup.txt
# wget https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master/wrz.txt
# wget https://www.github.developerdan.com/hosts/lists/ads-and-tracking-extended.txt
# wget https://www.github.developerdan.com/hosts/lists/tracking-aggressive-extended.txt
# wget https://www.hostsfile.org/Downloads/hosts.txt
# wget https://www.malwaredomainlist.com/hostslist/hosts.txt
#
# wget http://rlwpx.free.fr/WPFF/hmis.7z
# wget http://rlwpx.free.fr/WPFF/hpub.7z
# wget http://rlwpx.free.fr/WPFF/hrsk.7z
# wget http://rlwpx.free.fr/WPFF/hsex.7z
# wget http://rlwpx.free.fr/WPFF/htrc.7z
# wget https://winhelp2002.mvps.org/hosts.zip
#
# wget https://raw.githubusercontent.com/mitchellkrogza/Badd-Boyz-Hosts/master/hosts
# wget https://someonewhocares.org/hosts/hosts

# IMPORTANT: Do not Use trailing slashes in URLs, URIs or directory paths

package='Host Flash™' # Name of software installed by this installer
version='4.0.3 - 23rd April 2025' # Updated version with optimizations and fixes
debug='0'

## Clear screen
__clear() {
	if [ "$debug" -eq 0 ]; then
		clear
	fi
}

## Source loader
# Load source files
# This facilitates modularisation
__flying_sourcer() {
	local SourcerSection="$1"
	
	# Try to source the file using 'source' command, fallback to '.' if it fails
	# Note: The duplicate source command was removed as it was redundant
	if ! source "${SourcerSection}" 2>/dev/null; then
		. "${SourcerSection}"
	fi
}

# Clear arrays
unset app conf dir file in list log message rem menu select mode essentialpackages credits flush listc listcc listsc

# Declare associative arrays
declare -A app conf dir file list log message rem

# Declare regular arrays and types
declare -a menu # Menu options are set within __menu_main()
declare -a select # Menu options count
declare -a mode # Used for notices
declare -a essentialpackages # Packages to install to help the build process
declare -a credits # Hosts file credits
declare -a flush # DNS cache flush commands
declare -i listc listcc listsc # For list repository counts

# Remote Hosts
rem[gith]='https://github.com/VR51/host-flash' # Github home URL for this package.
rem[gitp]='https://github.com/VR51/host-flash.git' # Software source package git address
rem[tld]='https://data.iana.org/TLD/tlds-alpha-by-domain.txt' # Official list of valid TLDs

# Directories
#  These directories are created by dir[@] dump. Be careful when adding directories to this list
#
# Top level directories
dir[hfh]="$HOME/hostflash" # Host Flash Home directory
dir[src]="$HOME/src/hostflash" # Directory where source hosts files are stored locally
dir[conf]="$HOME/.config/hostflash" # Location of custom configuration files.
# Sub level directories
## These are permanent doc and log directories
dir[docs]="${dir[hfh]}/DOC" # Location of program documents. # To be written
dir[logs]="${dir[hfh]}/logs" # Location of host file logs.
dir[bck]="${dir[hfh]}/backups" # Location of host file backups.
## These are config directories
dir[lists]="${dir[conf]}/lists" # Modular lists
dir[menus]="${dir[conf]}/menus" # Modular menus
dir[plugs]="${dir[conf]}/plugins" # Modular plugins
## These are wiped each time a hosts file is built unless DEBUG is set to '1'.
dir[tmp]="${dir[src]}/tmp" # Directory where temporary files are stored locally
dir[tmpd]="${dir[tmp]}/downloads" # Directory where source hosts files downloaded and unpacked before being moved
dir[tmpu]="${dir[tmp]}/unprocessed" # Directory where unprocessed source hosts files are stored
dir[tmpp]="${dir[tmp]}/processed" # Directory where processed source hosts files are stored. This allows us to check events.

# Files
file[hosts]=''
# System hosts file location. Where it is copied from and where it is installed to.
# See next code block, it replaces this current section. This section is here for reference or in case there is need to manually set the path.
#
# file[hosts]='/etc/hosts' # Location of system hosts file in Unix, Unix-like and POSIX systems.
# file[hosts]='/private/etc/hosts' # iOS, Apple Mac
# file[hosts]='/system/etc/hosts' # Android
# file[hosts]='%SystemRoot%\System32\drivers\etc\hosts' # Windows NT, 2000, XP,[5] 2003, Vista, 2008, 7, 2012, 8, 10

# Custom Hosts File location
# file[hosts]='/enter/path/to/file/called/hosts' # Add the path to your system's hosts file then uncomment (remove the #) and save to activate.

__clear

if [ -z "${file[hosts]}" ]; then
	if [ -f "/system/etc/hosts" ]; then
		file[hosts]='/system/etc/hosts'
	elif [ -f "/private/etc/hosts" ]; then
		file[hosts]='/private/etc/hosts'
	elif [ -f "/etc/hosts" ]; then
		file[hosts]='/etc/hosts'
	else
		echo "Unable to detect the location of this system's hosts file."
		echo "Please edit the hostflash program at around line 175 to set a custom value for ${bold}file[hosts]${normal} to point to your system's hosts file"
		echo "and uncomment the line edited."
		echo "Alternatively, add ${bold}file[hosts]='/path/to/your/hosts'${normal} to ${bold}$HOME/.config/hostflash/.hfrc${normal} if the change should survive script updates."
		echo "Visit ${bold}${rem[gith]}${normal} if you want us to add your host file's location to the automatic detection list."
		echo "Press any key to exit $package"
		read a
		exit 1
	fi
fi

# HF Config Files
#  These are created by file[@] dump. Be careful when adding files to this list
file[conf]="${dir[conf]}/.hfrc" # Location of user's custom settings for Host Flash™.
file[confwl]="${dir[conf]}/.hfwlrc" # Location of the user's custom whitelist.
file[confwlw]="${dir[conf]}/.hfwlwrc" # Location of the user's custom whitelist-wild.
file[confbl]="${dir[conf]}/.hfblrc" # Location of the user's custom blacklist.
file[confcl]="${dir[conf]}/.hfclrc" # Location of the user's custom hosts lists.
file[confr]="${dir[conf]}/.hfremoved" # Hosts removed from hosts list during hosts build/update.
file[conftld]="${dir[conf]}/.hftld" # Location of valid TLD list.
# Log files
file[hist]="${dir[logs]}/history.txt" # Location of update history.
file[log]="${dir[logs]}/log.txt" # Location of the general process log file.
file[debug]="${dir[logs]}/debug.txt" # Location of debug logging file.
# Next files to be used in a later version of HF
file[confpost]="${dir[conf]}/.hfpost" # Location of the post processing blacklist (block hosts that are wild needlessly whitelisted)
file[confsl]="${dir[conf]}/.hfslrc" # Location of the user's hosts switch list.

# App Launcher Settings
# These are specific to the application/task manager installer (yet to be implemented)
app[icon]="${dir[src]}/data" # Directory where the application icon will be located.
app[bin]='/usr/bin' # Binary installation path. Where should the compiled binary be installed to? Exact path. # Not required for this installer.
app[icon]="hostflash.svg" # Icon name
app[type]='Application' # 
app[cats]='Utilities' # Application launcher categories
app[binary]="hostflash" # Name of the binary file that is this program.

# Detected settings
user="$(whoami)" # Current User
group="$(id -g -n "$user")" # Current user's primary group

###
# DECLARE LIST ARRAYS
###

# Declare custom list associative arrays. If they are not declared we cannot use them.

# Count Lists
listc=$(grep -E '\[status[[:digit:]]+]=' "$0" | wc -l) # Count lists in hostflash script
if grep -Eq '\[status[[:digit:]]+]=' "${file[confcl]}" 2>/dev/null; then
	listcc=$(grep -E '\[status[[:digit:]]+]=' "${file[confcl]}" | wc -l) # Count custom lists in .hfclrc
else
	listcc=0
fi
listsc=$((listc + listcc)) # Use arithmetic expansion instead of let

##
# LISTS
#
# These are set with
#
# list[status]='Enabled / Disabled' # + or - for TRUE or FALSE
# list[info]='List Domain' # The name of the list
# list[src]='Download URL' # From where the package will be retrieved
# list[file]='Download Package' # Name of package retrieved
# list[target]='Package Target' # Name of usable file in a retrieved zip package / Name of file created on retrieval if FLAG is raw
# list[ip]='0' # 0 or 1 for false or true. Add loopback IP address to downloaded list. This is required when a hosts list consists of domain names with no IP prefix. Not required for whitelists, in fact should never be set to '1' for whitelists.
#
# Changes to list[status] are stored in .hfrc
# Custom lists will be added to .hfclrc
#		Framework in place: conf etc... Needs menu section to be added.
##

# TO DO: Change to list[NUM TYPE]
#  https://hosts-file.net/?s=Download <-- DEAD. This is now a Malwarebytes browser addon.
#  Files from here now mirrored and updated at https://github.com/fredprod/host-file.net-backup
#  & https://github.com/blackskye-sx/host-file.net-backup
list[status1]='+'
list[info1]='hosts-file.net - Ad Servers (Liberal)'
list[src1]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file1]='ad_servers.txt'
list[target1]='ad_servers.txt'
list[ip1]='0'

list[status2]='+'
list[info2]='hosts-file.net - EMD (Liberal)'
list[src2]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file2]='emd.txt'
list[target2]='emd.txt'
list[ip2]='0'

list[status3]='+'
list[info3]='hosts-file.net - EXP (Liberal)'
list[src3]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file3]='exp.txt'
list[target3]='exp.txt'
list[ip3]='0'

list[status4]='+'
list[info4]='hosts-file.net - FSA (Liberal)'
list[src4]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file4]='fsa.txt'
list[target4]='fsa.txt'
list[ip4]='0'

list[status5]='+'
list[info5]='hosts-file.net - GRM (Liberal)'
list[src5]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file5]='grm.txt'
list[target5]='grm.txt'
list[ip5]='0'

list[status6]='+'
list[info6]='hosts-file.net - HFS (Liberal)'
list[src6]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file6]='hfs.txt'
list[target6]='hfs.txt'
list[ip6]='0'

list[status7]='+'
list[info7]='hosts-file.net - HJK (Liberal)'
list[src7]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file7]='hjk.txt'
list[target7]='hjk.txt'
list[ip7]='0'

list[status8]='+'
list[info8]='hosts-file.net - MMT (Liberal)'
list[src8]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file8]='mmt.txt'
list[target8]='mmt.txt'
list[ip8]='0'

list[status9]='+'
list[info9]='hosts-file.net - PHA (Liberal)'
list[src9]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file9]='pha.txt'
list[target9]='pha.txt'
list[ip9]='0'

list[status10]='+'
list[info10]='hosts-file.net - PSH (Liberal)'
list[src10]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file10]='psh.txt'
list[target10]='psh.txt'
list[ip10]='0'

list[status11]='+'
list[info11]='hosts-file.net - PUP (Liberal)'
list[src11]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file11]='pup.txt'
list[target11]='pup.txt'
list[ip11]='0'

list[status12]='+'
list[info12]='hosts-file.net - WRZ (Liberal)'
list[src12]='https://raw.githubusercontent.com/blackskye-sx/host-file.net-backup/master'
list[file12]='wrz.txt'
list[target12]='wrz.txt'
list[ip12]='0'

list[status13]='+'
list[info13]='mvps.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Big list)'
list[src13]='https://winhelp2002.mvps.org'
list[file13]='hosts.zip'
list[target13]='HOSTS'
list[ip13]='0'

list[status14]='+'
list[info14]='free.fr-Trackers (Moderate: Blocks trackers)'
list[src14]='http://rlwpx.free.fr/WPFF'
list[file14]='htrc.7z'
list[target14]='Hosts.trc'
list[ip14]='0'

list[status15]='+'
list[info15]='free.fr-Ad-Servers (Moderate: Blocks ad servers)'
list[src15]='http://rlwpx.free.fr/WPFF'
list[file15]='hpub.7z'
list[target15]='Hosts.pub'
list[ip15]='0'

list[status16]='+'
list[info16]='free.fr-Malware (Moderate: Blocks malware domains)'
list[src16]='http://rlwpx.free.fr/WPFF'
list[file16]='hrsk.7z'
list[target16]='Hosts.rsk'
list[ip16]='0'

list[status17]='+'
list[info17]='free.fr-Adult (Moderate: Blocks adult domains. Coincidentally blocks forums and some social sites)'
list[src17]='http://rlwpx.free.fr/WPFF'
list[file17]='hsex.7z'
list[target17]='Hosts.sex'
list[ip17]='0'

list[status18]='+'
list[info18]='free.fr-Misc (Moderate: Blocks miscellaneous domains)'
list[src18]='http://rlwpx.free.fr/WPFF'
list[file18]='hmis.7z'
list[target18]='Hosts.mis'
list[ip18]='0'

list[status19]='+'
list[info19]='someonewhocares.org (Liberal: Blocks mostly adware, spyware, malware and trackers. Small list)'
list[src19]='https://someonewhocares.org/hosts'
list[file19]='hosts'
list[target19]='hosts.txt'
list[ip19]='0'

list[status20]='-'
list[info20]='Removed - No longer accessible'
list[src20]=''
list[file20]=''
list[target20]=''
list[ip20]='0'

list[status21]='+'
list[info21]='KADhosts (Liberal: Blocks malware hosts)'
list[src21]='https://raw.githubusercontent.com/azet12/KADhosts/master/KADhosts.txt'
list[file21]=''
list[target21]='hosts.txt'
list[ip21]='0'

list[status22]='+'
list[info22]='yoyo.org (Liberal: Blocks adservers)'
list[src22]='https://pgl.yoyo.org/as/serverlist.php?showintro=0;hostformat=hosts'
list[file22]=''
list[target22]='hosts.txt'
list[ip22]='0'

list[status23]='+'
list[info23]='Mitchell Krog (Liberal: Blocks spam bot hosts)'
list[src23]='https://raw.githubusercontent.com/mitchellkrogza/Badd-Boyz-Hosts/master/hosts'
list[file23]=''
list[target23]='hosts.txt'
list[ip23]='0'

list[status24]='-'
list[info24]='Removed - No longer accessible'
list[src24]=''
list[file24]=''
list[target24]=''
list[ip24]='0'

list[status25]='+'
list[info25]='Developer Dan Ads and Trackers Safe List (Liberal: Blocks ads and trackers)'
list[src25]='https://www.github.developerdan.com/hosts/lists'
list[file25]='ads-and-tracking-extended.txt'
list[target25]='hosts.txt'
list[ip25]='0'

list[status26]='+'
list[info26]='Developer Dan Ads and Trackers Aggressive List (Moderate: Could cause browsing issues)'
list[src26]='https://www.github.developerdan.com/hosts/lists'
list[file26]='tracking-aggressive-extended.txt'
list[target26]='hosts.txt'
list[ip26]='0'

# Alternative address: https://raw.githubusercontent.com/AdAway/adaway.github.io/master/hosts.txt
list[status27]='+'
list[info27]='AdAway (Liberal: Blocks ad networks)'
list[src27]='https://adaway.org'
list[file27]='hosts.txt'
list[target27]='hosts.txt'
list[ip27]='0'

list[status28]='+'
list[info28]='hostsfile.org (Very Strict: Regular blocks + porn, gambling and gaming sites)\n'
list[src28]='https://www.hostsfile.org/Downloads'
list[file28]='hosts.txt'
list[target28]='hosts.txt'
list[ip28]='0'

# Others

list[status29]='+'
list[info29]='Community Whitelist (Host Flash™ whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src29]='https://gist.githubusercontent.com/VR51/7eaace2b6778ea508996/raw/'
list[file29]='remw'
list[target29]='whitelist.txt'
list[ip29]='0'

list[status30]='+'
list[info30]='Community Whitelist Wild (Host Flash™ wild whitelist. Unblocks a limited set of sites blocked by the other blacklists)'
list[src30]='https://gist.githubusercontent.com/VR51/9798c78337fe2f7ad589/raw/'
list[file30]='remww'
list[target30]='whitelist-wild.txt'
list[ip30]='0'

list[status31]='+'
list[info31]='Community Blacklist (Host Flash™ blacklist. Blocks a limited set of sites not blocked by other lists)'
list[src31]='https://gist.githubusercontent.com/VR51/ef3b90b1be2693a44f27/raw/'
list[file31]='remb'
list[target31]='hosts.txt'
list[ip31]='1'

list[status32]='+'
list[info32]='Local Whitelist (Your own custom whitelist)'
list[src32]='localhost'
list[file32]="${file[confwl]}"
list[target32]='whitelist.txt'
list[ip32]='0'

list[status33]='+'
list[info33]='Local Whitelist Wild (Your own custom wild whitelist)'
list[src33]='localhost'
list[file33]="${file[confwlw]}"
list[target33]='whitelist-wild.txt'
list[ip33]='0'

list[status34]='+'
list[info34]='Local blacklist (Your own custom blacklist)'
list[src34]='localhost'
list[file34]="${file[confbl]}"
list[target34]='hosts.txt'
list[ip34]='1'

# GENERAL

essentialpackages=( zip unzip 7z curl sed git )
	
conf[ess]=0 # Essentials # Install build essential software. 0 = Not done, 1 = Done
conf[upv]=0 # Update Host Flash™ program.
#conf[locv]=$($binary -v) # Installed package version
conf[inst]=$( ls -l "$0" | cut -d' ' -f 6-8) # $package installation date
conf[locv]="$version installed ${conf[inst]}"
# Use a timeout to prevent hanging if network is unavailable
conf[gitv]=$(curl -v --silent "${rem[gith]}/commit/master" --stderr - --connect-timeout 5 | grep '<relative-time datetime' | sed -E 's#.+">(.+)<.+#\1#')
networked=$? # Are we connected to the net? We are if $networked = 0
conf[hosts]=$( ls -l "${file[hosts]}" | cut -d' ' -f5 ) # Hosts file size
conf[hostt]=$( ls -l "${file[hosts]}" | cut -d' ' -f 6-8 ) # Hosts file timestamp
conf[hostc]=$( wc -l "${file[hosts]}" | cut -d' ' -f1 ) # Hosts file line count

conf[ip]='0.0.0.0' # Redirect IP address
conf[mode]='1' # Build Only or Build and Install 0 or 1

timestamp="$(date +"%Y-%m-%d-%H-%M-%S")"

# LOGS
# Log host file history, general log messages and debug messages
__log() {
	# @1 = File to store log (hist, log, or debug)
	# @2 = Message to store with log
	
	local log_file=$1
	local message=$2
	local now
	
	# Get current timestamp
	now="$(date +"%Y-%m-%d %H:%M:%S")"
	
	case "$log_file" in
		hist)
			# Only append message if it's not empty
			[ -n "$message" ] && echo "$message" >> "${file[hist]}"
			echo "$now: Line Count: ${conf[hostc]} | Bytes: ${conf[hosts]} | Timestamp: ${conf[hostt]} | Location: ${file[hosts]}" >> "${file[hist]}"
		;;
		log)
			echo "$now: $message" >> "${file[log]}"
		;;
		debug)
			echo "$now: $message" >> "${file[debug]}"
		;;
	esac
}

## END CONFIGS

## BEGIN

# Other settings
bold=$(tput bold)
normal=$(tput sgr0)

# Locate where we are
filepath="$( echo $PWD )"

# A Little precaution
cd "$filepath"

# Make/Remove directories and files

__download_tlds() {
	# Download TLD list if it doesn't exist or is older than 24 hours (1440 minutes)
	if [ ! -f "${file[conftld]}" ] || [ -n "$(find "${file[conftld]}" -mmin +1440 2>/dev/null)" ]; then
		# Download TLD list, convert to lowercase, and remove comments
		curl -s -L "${rem[tld]}" -o "${file[conftld]}.tmp"
		if [ $? -eq 0 ]; then
			# Convert to lowercase and remove comments
			sed -e 's/\(.*\)/\L\1/' "${file[conftld]}.tmp" | grep -vE '^#' > "${file[conftld]}"
			rm -f "${file[conftld]}.tmp"
		else
			__log "log" "Failed to download TLD list from ${rem[tld]}"
		fi
	fi
}
# __download_tlds # Get TLD list # Not yet used.

case "${debug}" in
	0)
		if test -d "${dir[tmp]}"; then
			rm -r "${dir[tmp]}" # Clean the tmp directory but not if we are debugging.
		fi
	;;
esac

# Make directories and files that do not yet exist
mkdir -p "${dir[@]}" # Make directories
touch -a "${file[@]}" # Make config files

# INSTALL RC SETTINGS

__repaint() {
	# Loads configs then clears the screen
	# Whatever calls this should reload the screen for the new configs to be reflected on the screen

	# @1 = type: soft, hard, conf, ret
	#  soft just refreshes the screen
	#  hard reloads the script in the current shell
	#  conf must be followed by a config file to load. Loads default conf then extra conf.
	#  'no argument' loads the default config file represented by ${file[conf]}
	# @2..@n = config file(s) to reload
	#
	# ret executes the function stated in $2

	__clear
	
	# Create array from arguments with proper quoting
	local in=( "$@" )

	case "${in[0]}" in
		soft) # Reset variables
			unset
			__repaint
		;;
		
		hard) # Restart this script
			exec bash "$0"
		;;

		conf) # Include basic conf and any extras listed in $@
			# Process additional config files
			for i in "${in[@]:1}"; do
				[ -f "$i" ] && __flying_sourcer "$i"
			done
			# Always load the main config file
			[ -f "${file[conf]}" ] && __flying_sourcer "${file[conf]}"
		;;
		
		ret) # Execute a function
			# Only execute if the function exists
			if [ -n "${in[1]}" ] && declare -F "${in[1]}" >/dev/null; then
				"${in[1]}"
			fi
		;;

		*) # Include basic conf only
			[ -f "${file[conf]}" ] && __flying_sourcer "${file[conf]}"
		;;
	esac
}


# Include custom lists

__repaint conf "${file[confcl]}"

##
# Actions
##

__run() {
	# Check if running in a terminal, if not launch terminal
	# Otherwise run the main menu
	
	if ! tty -s; then
		__launch
	else
		__menu_main "${1:-}" # This will be changed when CLI added
	fi
}

__hosts_update() {
	# Read the file of hosts and remove any line listed in the input whitelist file
	# The results are logged in a file in the config directory.

	# @1 = type: (file) norm or wild, or (string) linen or linew
	# @2 = file to remove data from
	# @3 = file containing lines of data to remove from @2 or single line of text to remove from @2
	
	# Validate inputs
	if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
		__log "log" "Error: Missing parameters in __hosts_update"
		return 1
	fi
	
	# Use local variables for clarity and safety
	local input_type="$1"
	local target_file="$2"
	local filter_source="$3"
	local temp_file
	local line
	local escaped_ip
	
	# Check if target file exists
	if [ ! -f "$target_file" ]; then
		__log "log" "Error: Target file '$target_file' not found"
		return 1
	fi

	# Escape IP for grep pattern (convert periods to character classes)
	escaped_ip=$(echo "${conf[ip]}" | sed 's/\./[.]/g')
	
	# Process according to input type
	case "$input_type" in
		norm)
			# Log header for non-wild whitelist processing
			echo -ne "\n###\n# NON-WILD WHITELIST\n###\n\n" >> "${file[confr]}"

			# Process each line in the filter file
			while IFS= read -r line || [ -n "$line" ]; do
				# Skip empty lines and comments
				[ -z "$line" ] || [[ "$line" =~ ^[[:space:]]*# ]] && continue
				
				# Escape dots in the line for grep pattern
				escaped_line=$(echo "$line" | sed 's/\./[.]/g')
				
				# Log the line being processed
				echo -ne "\n# $line\n\n" >> "${file[confr]}"
				
				# Log removed entries
				grep -i "^${escaped_ip}[[:blank:]]${escaped_line}$" "$target_file" >> "${file[confr]}" || true
				
				# Remove entries from target file
				temp_file="$(mktemp)"
				grep -vi "^${escaped_ip}[[:blank:]]${escaped_line}$" "$target_file" > "$temp_file" || true
				mv -f "$temp_file" "$target_file"
			done < "$filter_source"
		;;

		wild)
			# Log header for wild whitelist processing
			echo -ne "\n###\n# WILD WHITELIST PASS 2 - WILD\n###\n\n" >> "${file[confr]}"

			# Process each line in the filter file
			while IFS= read -r line || [ -n "$line" ]; do
				# Skip empty lines and comments
				[ -z "$line" ] || [[ "$line" =~ ^[[:space:]]*# ]] && continue
				
				# Escape dots in the line for grep pattern
				escaped_line=$(echo "$line" | sed 's/\./[.]/g')
				
				# Log the line being processed
				echo -ne "\n# $line\n\n" >> "${file[confr]}"
				
				# Log removed entries
				grep -i "^${escaped_ip}[[:blank:]].*[.]${escaped_line}" "$target_file" >> "${file[confr]}" || true
				
				# Remove entries from target file
				temp_file="$(mktemp)"
				grep -vi "^${escaped_ip}[[:blank:]].*[.]${escaped_line}" "$target_file" > "$temp_file" || true
				mv -f "$temp_file" "$target_file"
			done < "$filter_source"
		;;

		linen) # Single line exact match
			# Escape dots in the data for grep pattern
			local data=$(echo "$filter_source" | sed 's/\./[.]/g')
			
			# Log removed entries
			grep -i "^${escaped_ip}[[:blank:]]${data}$" "$target_file" >> "${file[confr]}" || true
			
			# Remove entries from target file
			temp_file="$(mktemp)"
			grep -vi "^${escaped_ip}[[:blank:]]${data}$" "$target_file" > "$temp_file" || true
			mv -f "$temp_file" "$target_file"
		;;

		linew) # Single line wildcard match
			# Escape dots in the data for grep pattern
			local data=$(echo "$filter_source" | sed 's/\./[.]/g')
			
			# Log removed entries
			grep -i "^${escaped_ip}[[:blank:]].*[.]${data}" "$target_file" >> "${file[confr]}" || true
			
			# Remove entries from target file
			temp_file="$(mktemp)"
			grep -vi "^${escaped_ip}[[:blank:]].*[.]${data}" "$target_file" > "$temp_file" || true
			mv -f "$temp_file" "$target_file"
		;;

		*)
			__log "log" "Error: Unknown input type '$input_type' in __hosts_update"
			return 1
		;;
	esac

	return 0
}

__conf_update() {
	# Add or remove a single host from the .hf*rc config files
	# ! Considered merging this function with __hosts_update. Opted to keep the two separate. It simplifies input sanitization.

	# @1 = type: add, rem, remw, or remn (remove by line number)
	# @2 = data to add/remove
	# @3 = file to add/remove @1 to/from

	# Validate inputs
	if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
		__log "log" "Error: Missing parameters in __conf_update"
		return 1
	fi

	# Use local variables for clarity and safety
	local action="$1"
	local data="$2"
	local target_file="$3"
	local temp_file

	# Check if target file exists
	if [ ! -f "$target_file" ]; then
		__log "log" "Warning: Target file '$target_file' not found in __conf_update"
		touch "$target_file" # Create the file if it doesn't exist
	fi

	case "$action" in
		add)
			# Only add the entry if it doesn't already exist
			if ! grep -qF "$data" "$target_file"; then
				echo "$data" >> "$target_file"
				__log "log" "Added entry '$data' to $target_file"
			return 0
			fi
		;;

		rem)
			# Use grep to safely remove exact matches
			temp_file="$(mktemp)"
			grep -v "^${data}$" "$target_file" > "$temp_file" || true
			mv -f "$temp_file" "$target_file"
			__log "log" "Removed exact match entries for '$data' from $target_file"
		;;

		remw)
			# Use grep to safely remove wildcard matches
			temp_file="$(mktemp)"
			grep -v "${data}" "$target_file" > "$temp_file" || true
			mv -f "$temp_file" "$target_file"
			__log "log" "Removed wildcard match entries for '$data' from $target_file"
		;;

		remn)
			# Remove by line number if data is a valid number
			if [[ "$data" =~ ^[0-9]+$ ]]; then
				temp_file="$(mktemp)"
				sed "${data}d" "$target_file" > "$temp_file"
				mv -f "$temp_file" "$target_file"
				__log "log" "Removed line $data from $target_file"
			else
				__log "log" "Error: Invalid line number '$data' in __conf_update"
				return 1
			fi
		;;

		*)
			__log "log" "Error: Unknown action '$action' in __conf_update"
			return 1
		;;
	esac

	# Remove empty lines from the file
	temp_file="$(mktemp)"
	grep -v '^$' "$target_file" > "$temp_file" || true
	mv -f "$temp_file" "$target_file"

	return 0
}

__conf_delete() {
	__repaint conf "${file[confcl]}"
	
	# Delete specified file
	# @1 = File to delete
	# @2 = File's friendly name

	# Validate inputs
	if [ -z "$1" ] || [ -z "$2" ]; then
		__log "log" "Error: Missing parameters in __conf_delete"
		return 1
	fi

	# Use local variables for clarity and safety
	local target_file="$1"
	local friendly_name="$2"
	local choice

	printf "${bold}DELETE CONFIG FILES${normal}"
	printf "\n\nReset chosen configuration file\n\n"

	# Display menu
	unset menu
	menu[1]="Proceed: Reset ${friendly_name} by deleting file ${target_file}"
	menu[2]="Return: Do not reset ${friendly_name}"

	local m=1
	while [ $m -le ${#menu[@]} ]; do
		printf "%d) %s\n" "$m" "${menu[$m]}"
		((m++))
	done
	
	printf "\nChoose an option then press Enter:\n"
	read -r choice
	
	while true; do
		case "$choice" in
			1)
				if [ -f "$target_file" ]; then
					rm -f "$target_file"
					__log "log" "Deleted configuration file: $target_file"
					printf "%s reset.\n" "$friendly_name"
					printf "\nPress any key to continue\n"
					touch "$target_file"
					read -r something
					__repaint conf "${file[confcl]}"
					__menu_reset_confs
				else
					printf "%s not found.\n" "$friendly_name"
					printf "Custom settings not yet created. Nothing to do. Nothing done.\n"
					printf "\nPress any key to continue\n"
					read -r something
				fi
				__menu_reset_confs
			;;
			
			2)
				__menu_reset_confs
			;;
			
			*)
				__repaint
			;;
		esac
	done

}

function __remove_custom_list_entry_menu() {
	filename=$1
	description=$2

	printf "Custom $description is located at $filename\n\n"
	__display_file $filename
	printf "\nType the line number to remove then press Enter. Press 0 to exit:\n\n"
	read a

	case $a in
		0)
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;

		*)
			__conf_update 'remn' "$a" "$filename"
			__repaint '__menu_custom_list_management' # Effectively 'Return here'
		;;
	esac
}

function __display_file() {
	filename=$1

	n=1
	while read LINE; do
		printf "$n) $LINE\n"
		let n=n+1
	done < $filename
}

function __status() {
	# Change status of list: On or Off.
	
	# @1 = host list to change status of
	
	n=$1
	if grep "list\[status${n}]='-'" "${file[conf]}"
	then
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='+'" >> "${file[conf]}"
	else
		sed -i "/list\[status${n}]=/d" "${file[conf]}"
		echo -e "list[status${n}]='-'" >> "${file[conf]}"
	fi
	
}

function __build() {
	# Build the hosts file: download lists, clean them, merge them, create new hosts file

	# Download lists. Merge them into new hosts file
	n=1
	until [ $n -eq 0 ]; do

		status="${list[status${n}]}"
		info="${list[info${n}]}"
		src="${list[src${n}]}"
		file="${list[file${n}]}"
		target="${list[target${n}]}"
		ip="${list[ip${n}]}"

		if test "$status" = '+' # The list is enabled
		then

			case "$src" in

				localhost)

					case "$target" in
						whitelist-wild.txt)
							cat "$file" >> "${dir[tmpu]}/whitelist-wild.txt"
						;;
						
						whitelist.txt)
							cat "$file" >> "${dir[tmpu]}/whitelist.txt"
						;;
						
						*) # Is a hosts.txt file
							cat "$file" >> "${dir[tmpu]}/hosts.txt.$n"
						;;
					esac
					
				;;

				*)

					# Grab source hosts file from its remote location
					case "$file" in
						remw)
							file="whitelist.txt.$n"
							curl -L -e "$src" "$src" -o "${dir[tmpd]}/$file"
						;;
						remww)
							file="whitelist-wild.txt.$n"
							curl -L -e "$src" "$src" -o "${dir[tmpd]}/$file"
						;;
						remb)
							file="hosts.txt.$n"
							curl -L -e "$src" "$src" -o "${dir[tmpd]}/$file"
						;;
						*)
							curl -L -e "$src" "$src/$file" -o "${dir[tmpd]}/$file"
						;;
					esac

					# Filter by type
					case "$target" in

						whitelist-wild.txt)
							cat "${dir[tmpd]}/$target" >> "${dir[tmpu]}/whitelist-wild.txt"
							rm "${dir[tmpd]}/$target"
						;;
						
						whitelist.txt)
							cat "${dir[tmpd]}/$target" >> "${dir[tmpu]}/whitelist.txt"
							rm "${dir[tmpd]}/$target"
						;;
						
						*) # $target is a source hosts file
							# Doing this back-to-front so we do not need to test text mime types
							# Attempt to extract package content
							# If a package is found it contains the target file
							unzip -o "${dir[tmpd]}/$file" -d "${dir[tmpd]}" > /dev/null 2>&1 # Try unzip. Suppress errors
							if test $? -eq 0
							then
								mv "${dir[tmpd]}/$target" "${dir[tmpu]}/hosts.txt.$n"
								rm "${dir[tmpd]}/$file"
							else # If unzip failed try 7z
								7z e -y "${dir[tmpd]}/$file" -o"${dir[tmpd]}" # Try 7z. Suppress errors
								if test $? -eq 0
								then
									mv "${dir[tmpd]}/$target" "${dir[tmpu]}/hosts.txt.$n"
									rm "${dir[tmpd]}/$file"
								else # It's not a package file so treat as a txt file: just move and rename
									mv "${dir[tmpd]}/$file" "${dir[tmpu]}/hosts.txt.$n"
								fi
							fi
						;;
					
					esac

				;;

			esac

			# Add IP address prefix if required
			case "${ip}" in

				1)
					sed -r -i "s/^/${conf[ip]} /g" "${dir[tmpu]}/$target.$n" # Loopback IP
				;;

			esac

		fi

		credits+=("# Includes hosts blacklist from $info\n")

		if test ${#status} -eq 0
		then
			c=$n
			let c=c-1
			let n=n-n
		else
			let n=n+1
		fi

	done

	# Merge files. We do it this way to simplify debugging
	until [ $c -eq 0 ]; do

		echo "File: $c" >> "${dir[tmp]}/merge-counter.txt"

		if test -f "${dir[tmpu]}/hosts.txt.$c"
		then
			cat "${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmpu]}/hosts-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmp]}/merge-counter.txt" # Log the merge
				mv -f "${dir[tmpu]}/hosts.txt.$c" "${dir[tmpp]}/hosts.txt.$c" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/hosts.txt.$c" >> "${dir[tmp]}/merge-counter.txt" # Log the merge
			fi
		fi

		# No need to number whitelist files. We know what we are dealing with here so we use the same file throughout.
		if test -f "${dir[tmpu]}/whitelist.txt"
		then
			cat "${dir[tmpu]}/whitelist.txt" >> "${dir[tmpu]}/whitelist-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/whitelist.txt" >> "${dir[tmp]}/merge-counter.txt"
				cp "${dir[tmpu]}/whitelist.txt" "${dir[tmpp]}/whitelist.txt" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/whitelist.txt" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi

		if test -f "${dir[tmpu]}/whitelist-wild.txt"
		then
			cat "${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmpu]}/whitelist-wild-temp.txt"
			if test $? -eq 0; then
				echo "Success: ${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmp]}/merge-counter.txt"
				cp "${dir[tmpu]}/whitelist-wild.txt" "${dir[tmpp]}/whitelist-wild.txt" # Move the merged file from unprocessed to processed
			else
				echo "Fail: ${dir[tmpu]}/whitelist-wild.txt" >> "${dir[tmp]}/merge-counter.txt"
			fi
		fi
		
		let c=c-1
		
	done

	__repaint

	printf "This next part could take some time.\nLook in ${dir[tmpu]} to view activity in realtime.\n\nProcessing...\n"

	# Convert non-UTF8 characters to UTF8 to fix characters in French lists.
	# Throw away anything that does not begin with an IP4 address.
	# We alternate file name between hosts-temp.txt and hosts-temp-copy.txt as we work on them.

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/whitelist-temp.txt" > "${dir[tmpu]}/whitelist-temp-copy.txt"
	sed '/^$/d' "${dir[tmpu]}/whitelist-temp-copy.txt" > "${dir[tmpu]}/whitelist-temp.txt"
	rm "${dir[tmpu]}/whitelist-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/whitelist-wild-temp.txt" > "${dir[tmpu]}/whitelist-wild-temp-copy.txt"
	sed '/^$/d' "${dir[tmpu]}/whitelist-wild-temp-copy.txt" > "${dir[tmpu]}/whitelist-wild-temp.txt"
	rm "${dir[tmpu]}/whitelist-wild-temp-copy.txt"

	iconv -c -t UTF-8//TRANSLIT < "${dir[tmpu]}/hosts-temp.txt" > "${dir[tmpu]}/hosts-temp-copy.txt"
	rm "${dir[tmpu]}/hosts-temp.txt"

	#	Format raw list data in hosts-temp.txt
	sed -r -i 's/[[:blank:]]+/ /g' "${dir[tmpu]}/hosts-temp-copy.txt" # Convert all spaces and tabs to a single space
	grep -Ev "[[:blank:]](ip6-)?(localhost|loopback|localnet|mcastprefix|allnodes|allrouters)\s?\b" "${dir[tmpu]}/hosts-temp-copy.txt" > "${dir[tmpu]}/hosts-temp.txt" # Remove localhost lines - the computer's installed host file already has localhost defined the way it should be
	grep -E '^[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?\.[012][01-9]?[01-9]?' "${dir[tmpu]}/hosts-temp.txt" > "${dir[tmpu]}/hosts-temp-copy.txt" # Extract and keep only lines that begin with an IP address
	sed -r -i "s/^[012][\.01-9]{1,2}+[[:blank:]]/${conf[ip]} /g" "${dir[tmpu]}/hosts-temp-copy.txt" # Replace with a single space and the new IP address everything up to, and including, the first tab in each line

	# Sort the lists
	if test -f "${dir[tmpu]}/hosts-temp-copy.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/hosts-temp-copy.txt" # Standardise line endings
		sort -f -u "${dir[tmpu]}/hosts-temp-copy.txt" > "${dir[tmpu]}/hosts-temp.txt"
		rm "${dir[tmpu]}/hosts-temp-copy.txt"
	fi

	if test -f "${dir[tmpu]}/whitelist-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/whitelist-temp.txt" # Fix line endings
		sort -f -u "${dir[tmpu]}/whitelist-temp.txt" > "${dir[tmpu]}/whitelist.txt"
		rm "${dir[tmpu]}/whitelist-temp.txt"
	fi

	if test -f "${dir[tmpu]}/whitelist-wild-temp.txt"
	then
		sed -i 's/\r$//' "${dir[tmpu]}/whitelist-wild-temp.txt" # Fix line endings
		sort -f -u "${dir[tmpu]}/whitelist-wild-temp.txt" > "${dir[tmpu]}/whitelist-wild.txt"
		rm "${dir[tmpu]}/whitelist-wild-temp.txt"
	fi

	# Process whitelist -- remove whitelisted domains from hosts-temp.txt
	# Always pass wild through norm too
	__hosts_update "norm" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist.txt"
	__hosts_update "norm" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist-wild.txt"
	__hosts_update "wild" "${dir[tmpu]}/hosts-temp.txt" "${dir[tmpu]}/whitelist-wild.txt"
	
	# hosts.txt should not exist at this point
	if test -f "${dir[tmpu]}/hosts.txt"
	then
		rm "${dir[tmpu]}/hosts.txt"
	fi

	# Get head of the existing hosts file stored at /etc/hosts
	# Remove old Host Flash™ blacklist from existing hosts file, assuming blacklist exists
	# Remove empty lines from the end of the header
	# This creates file hosts.head which is used a few lines down from here

	if grep -zPo '# Host.? Flash' "${file[hosts]}"
	then
		grep -zPo '(?s).*# Host.? Flash' "${file[hosts]}" | head -n -1 | grep -v '^[[:space:]]$' > "${dir[tmpu]}/hosts.head" # Remove old HF data, remove HF header remove empty lines.
	else
		cp "${file[hosts]}" "${dir[tmpu]}/hosts.head" # No existing hostsfile so just copy hosts to hosts.head
	fi

	printf '\n\n# Host Flash™ Firewall\n\n# Credits\n\n' >> "${dir[tmpu]}/hosts.head" # Add HF heading

	for i in "${credits[@]}" ; do
		printf "$i" >> "${dir[tmpu]}/hosts.head" # Add HF list provider credits
	done

	printf "\n\n# Installed with $package\n\n# Visit host-flash.com to learn more\n\n" >> "${dir[tmpu]}/hosts.head" # Add HF credit

	cat "${dir[tmpu]}/hosts.head" "${dir[tmpu]}/hosts-temp.txt" > "${dir[src]}/hosts.txt" # Merge the old head with the new hosts blacklist

}

__enable() {
	# Install Host Flash™ hosts list to /etc/hosts

	echo "Enabling Host Flash hosts file..."
	
	# Check if we have the hosts file to install
	if [ ! -f "${dir[src]}/hosts.txt" ]; then
		message[enable]="$package hosts file not found. Have you built it yet?"
		__log "log" "Error: hosts.txt not found when trying to enable Host Flash"
		return 1
	fi

	# Get su authority
	if ! sudo -v; then
		__log "log" "Error: Failed to obtain sudo privileges for hosts file installation"
		message[enable]="Failed to obtain necessary permissions. Please run as a user with sudo privileges."
		return 1
	fi

	# Backup original hosts file before first ever use of Host Flash™ in this system.
	# Only happens if the backup does not yet exist.
	if [ ! -f "${file[hosts]}.hf.original" ]; then
		echo "Creating original hosts file backup..."
		if sudo cp "${file[hosts]}" "${file[hosts]}.hf.original"; then
			# Create a zip backup in the backup directory
			zip -q "${dir[bck]}/hosts.original.zip" "${file[hosts]}.hf.original"
			__log "hist" "Created original hosts file backup"
		else
			__log "log" "Error: Failed to create original hosts file backup"
			message[enable]="Failed to create original hosts file backup."
			sudo -k
			return 1
		fi
	fi

	# Legacy support for versions of HF < 4
	if [ ! -f "${dir[bck]}/hosts.original.zip" ] && [ -f "${file[hosts]}.hf.original" ]; then
		cp "${file[hosts]}.hf.original" "${dir[bck]}/hosts.original"
		__log "hist" "Created legacy backup for compatibility with HF < 4"
	fi

	# Backup current hosts file before installing the new one
	echo "Backing up current hosts file..."
	zip -q "${dir[bck]}/hosts-$timestamp.zip" "${file[hosts]}" 

	# Install the new hosts file
	echo "Installing new hosts file..."
	if sudo mv -f "${dir[src]}/hosts.txt" "${file[hosts]}"; then
		__log "hist" "Successfully installed new hosts file"
		echo "Successfully installed new hosts file."
		
		# Help the new hosts file take effect
		__cleandns
		message[enable]="Host Flash hosts file successfully installed."
	else
		__log "log" "Error: Failed to install new hosts file"
		message[enable]="Failed to install new hosts file."
		sudo -k
		return 1
	fi

	# Drop sudo privileges
	sudo -k
	return 0
}

__disable() {
	# Remove Host Flash™ hosts list from /etc/hosts

	echo "Disabling Host Flash hosts file..."
	
	# Get su authority
	if ! sudo -v; then
		__log "log" "Error: Failed to obtain sudo privileges for hosts file restoration"
		message[disable]="Failed to obtain necessary permissions. Please run as a user with sudo privileges."
		return 1
	fi
	
	# Create a temporary copy of the hosts file
	if ! cp "${file[hosts]}" "${dir[tmp]}/hosts.copy"; then
		__log "log" "Error: Failed to create temporary copy of hosts file"
		message[disable]="Failed to create temporary copy of hosts file."
		sudo -k
		return 1
	fi

	# Check if Host Flash is installed
	if grep -q '# Host.* Flash' "${dir[tmp]}/hosts.copy"; then
		echo "Removing Host Flash entries from hosts file..."
		
		# Create a backup before modifying
		zip -q "${dir[bck]}/hosts-disabled-$timestamp.zip" "${file[hosts]}"
		
		# Remove Host Flash entries while preserving the original content
		if grep -zPo '(?s).*# Host.? Flash' "${dir[tmp]}/hosts.copy" | \
		   head -n -1 | grep -v '^[[:space:]]$' > "${dir[tmp]}/hosts.head" && \
		   sudo mv -f "${dir[tmp]}/hosts.head" "${file[hosts]}"; then
			
			__log "hist" "Successfully disabled Host Flash hosts file"
			echo "Successfully disabled Host Flash hosts file."
			
			# Help the new hosts file take effect
			__cleandns
			message[disable]="Host Flash hosts file successfully disabled."
		else
			__log "log" "Error: Failed to disable Host Flash hosts file"
			message[disable]="Failed to disable Host Flash hosts file."
			sudo -k
			return 1
		fi
	else
		__log "log" "Host Flash not found in hosts file"
		message[disable]="$package not installed. Nothing to do."
	fi

	# Drop sudo privileges
	sudo -k
	return 0
}

__cleandns() {
	# Clean the DNS local servers to help the new hosts file take effect
	# We try multiple methods since different distributions use different services

	echo "Flushing DNS caches..."
	__log "log" "Attempting to flush DNS caches"
	
	# Define an array of commands to try
	local flush=(
		'systemd-resolve --flush-caches'        # Modern systemd systems
		'rndc restart'                           # BIND DNS server
		'pdnsd-ctl empty-cache'                  # pdnsd caching DNS server
		'systemctl restart systemd-resolved'     # systemd-resolved service
		'systemctl restart network.service'      # Generic network service
		'systemctl restart wicd.service'         # WICD network manager
		'systemctl restart NetworkManager.service' # NetworkManager (Fedora, Manjaro, Arch)
		'service network-manager restart'        # Debian network manager
		'service nscd restart'                   # Name service cache daemon
		'service dnsmasq restart'                # Lightweight DNS forwarder and DHCP server
		'service dns-clean restart'              # Ubuntu/Debian DNS cache cleaner
		'service network restart'                # RHEL/CentOS network service
		'service named restart'                  # BIND DNS server (alternative method)
		'service networking force-reload'        # Other networking service
		'/etc/init.d/network-manager restart'    # Alternative network manager path
		'/etc/init.d/nscd restart'              # Alternative nscd path
		'/etc/init.d/dnsmasq restart'           # Alternative dnsmasq path
		'/etc/init.d/dns-clean restart'         # Linux Mint DNS cleaner
		'/etc/init.d/network restart'           # Alternative network service path
		'/etc/init.d/named restart'             # Alternative named service path
		'/etc/init.d/networking force-reload'   # Alternative networking reload
		'ipconfig /flushdns'                     # Windows (unlikely to work in this context)
		'killall -HUP mDNSResponder'             # macOS (unlikely to work in this context)
	)

	# Ensure we have sudo privileges
	sudo -v || {
		__log "log" "Error: Failed to obtain sudo privileges for DNS cache flushing"
		return 1
	}

	# Try each command and ignore errors
	for cmd in "${flush[@]}"; do
		printf "${bold}Attempting to flush DNS cache${normal} using command: %s\n" "$cmd"
		# Execute the command but don't fail if it doesn't work
		sudo bash -c "$cmd" > /dev/null 2>&1
		if [ $? -eq 0 ]; then
			printf "${bold}Success${normal}\n\n"
			__log "log" "Successfully flushed DNS cache using: $cmd"
		else
			printf "${normal}Command not available or failed (this is normal)\n\n"
		fi
	done
	
	printf "${bold}DNS cache flush attempts completed.${normal}\n"
	__log "log" "DNS cache flush attempts completed"
	
	# Drop sudo privileges
	sudo -k
	return 0

}

##
# MENUS
##

# Main Menu

function __menu_main() {

	__repaint conf "${file[confcl]}"

	# $1 = instruction

	while true; do

		if test "$?" -eq 0
		then

			case "${conf[mode]}" in

				0)
					mode[0]='MODE: Build Hosts Firewall Only\n'

				;;

				1)
					mode[0]='MODE: Build and Install Hosts Firewall\n'

				;;

			esac

			# Set Menu Options

			unset menu
			menu[1]='List Management (enable or disable repositories)'
			menu[2]='Custom List Management (add or remove whitelist/blacklist rules)\n'

			menu[3]="[${conf[ip]}] - Change redirect IP address\n"

			menu[4]='Change Build/Install Mode\n'

			case "${conf[mode]}" in

				0)
					menu[5]='Build Host Flash™ list but do not install.\n'

				;;

				1)
					menu[5]='Build and Install Host Flash™ list.\n'

				;;

			esac

			menu[6]='Enable Host Flash™ list.'
			menu[7]='Disable Host Flash™ list.'
			case "${conf[mode]}" in

				0)
					menu[8]='Update hosts file with new custom rules but do not enable new hosts file\n'

				;;

				1)
					menu[8]='Update and Enable hosts file with new custom rules\n'

				;;

			esac
			menu[9]='Flush DNS rules\n'

			menu[10]='Restore original hosts file.\n'

			menu[11]="Reset $package configs and files (select in next menu)"

			case "${conf[ess]}" in

				0)
					menu[1000]='Install missing software packages needed by Host Flash™\n'

				;;

			esac

			printf $bold
			printf "${mode[0]}\n"
			printf $normal

			printf "MENU\n\n"

			n=1
			for i in "${menu[@]}"; do
				if [ "$i" == '' ]; then
					printf "\n"
				else
					printf "$n) $i\n"
					select[$n]=$n
					let n=n+1
				fi
			done

			printf "\nR) Restart $package\n"
			printf "\n0) Exit\n\n"

			# Instructions
			
			printf "INSTRUCTIONS: a) Select lists to install with option 1, b) optionally add custom domains to blacklist or whitelist, c) build the hosts file firewall with option 5, before you d) Enable the newly built hosts file firewall with option 6. Change MODE to 'Build and Install' to set $package to automatically install the hosts file after it is built. $package will only work if the Essential Software is installed.\n\n"
			
			# Notices

			printf $bold

			printf "\nGENERAL INFO\n"
				
			printf $normal

			printf "\n System $package: ${conf[locv]}"
			printf "\n Latest git commit: ${conf[gitv]}\n"
			printf "\n Hosts File Info: Line Count: ${conf[hostc]} | Bytes: ${conf[hosts]} | Timestamp: ${conf[hostt]} | Location: ${bold}${file[hosts]}${normal}\n"
			
			printf "\nIf the computer crashes during installation lower the number of lists processed or cool your computer then try again.\n"

			printf $bold
				printf "\nChoose Wisely: "
			printf $normal
			read REPLY
		
		else
			REPLY=$1
		fi

		case $REPLY in

		1) # Choose lists to download # When moved to its own menu this will only be [[:num:]]
			__menu_list_management

		;;
		
		2) # Manage custom whitelists and blacklists
			__menu_custom_list_management
			
		;;

		3) # Change redirect IP address

			printf "Current Redirect IP: ${conf[ip]}"
			printf "\nType in new Redirect IP then press Enter:\n\n"
			read ip

			if grep "conf\[ip]=" "${file[conf]}"
			then
				sed -i "s/conf\[ip]='.*'/conf\[ip]='$ip'/g" "${file[conf]}"
			else
				echo -e "conf""[ip]='$ip'" >> "${file[conf]}"
			fi

			__repaint

		;;

		4) # Set Mode

			if grep "conf\[mode]='0'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='0'/conf\[mode]='1'/g" "${file[conf]}"
				
			elif grep "conf\[mode]='1'" "${file[conf]}"
			then
				sed -i "s/conf\[mode]='1'/conf\[mode]='0'/g" "${file[conf]}"
				
			else
				echo -e "conf""[mode]='1'" >> "${file[conf]}"
			fi

			__repaint

		;;

		5) # Build or Build and Install the Host Flash™ hosts file

			__build
			
			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;

		6) # Enable Host Flash™ hosts list

			__enable
			__repaint

		;;

		7) # Disable Host Flash™ hosts list

			__disable
			
			if test "${message[disable]}"
			then
				printf "\n${message[disable]}\nPress any key."
				read -a
			fi

			__repaint

		;;

		8) # Update hosts file with new custom rules

			__clear

			printf "This next part could take some time.\nLook in ${dir[tmp]} to view activity in realtime.\n\nProcessing...\n"

			cp "${file[hosts]}" "${dir[tmp]}/hosts-temp.txt"
			cat "${dir[tmp]}/hosts-temp.txt" "${file[confbl]}" >> "${dir[tmp]}/hosts.txt"
			
			# Always pass wild through norm too
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwl]}"
			__hosts_update "norm" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"
			__hosts_update "wild" "${dir[tmp]}/hosts.txt" "${file[confwlw]}"

			mv -f "${dir[tmp]}/hosts.txt" "${dir[src]}/hosts.txt"

			case "${conf[mode]}" in
			
				1)
			
					__enable
					
					if test "${message[enable]}"
					then
						printf "\n${message[enable]}\nPress any key."
						read -a
					fi
					
				;;
				
			esac
			
			__repaint hard

		;;
		
		9)
			__clear
			__cleandns
			printf "\nPress any key"
			read a
			__repaint
		
		;;

		10) # Restore original hosts list

			if test -f "${file[hosts]}.hf.original"
			then # Restore the backup head from the original hosts file
				sudo mv -f "${file[hosts]}.hf.original" "${file[hosts]}"
			fi

			__repaint

		;;

		11) # Reset Custom Configs

			__menu_reset_confs

			__repaint hard

		;;

		12) # Install software packages necessary to build the package

			case "${conf[ess]}" in
			
				0)

					printf "\nThis will attempt to install the following packages:\n"

					for i in "${essentialpackages[@]}"; do
						printf "$i "
					done

					printf "\nContinue to install them: Yn:\n"
					read a
					
					let n=1
					while true; do
						case $a in

						y|Y)
						
							case $n in
							1)
								echo -e "conf""[ess]='1'" >> "${file[conf]}"
								sudo apt-get update
								let n=n+1
							;;
							esac
							
							for i in "${essentialpackages[@]}"; do
								sudo apt-get build-dep -y -q $i
								sudo apt-get install -y -q --install-suggests $i
							done

							printf "\nPress any key to continue\n"
							read something
							__repaint

						;;

						n|N)

							__repaint

						;;
						
						*)

						esac
						
					done
					
				;;
				
			esac

		;;
		
		[Rr])
			__repaint hard
		;;

		0) # Exit

			exit 0

		;;

		*)

		esac

	done

}


# Sub Menus

function __menu_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"
		
		# Display lists available
		# $listsc # Value discovered during list array auto declares (see above)
		
		n=1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter list number to enable [+] or disable [-] then press Enter.\n"
		printf "\nType ${bold}E${normal} to Add, Remove or Edit remote hosts list providers.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			[Ee])
				__menu_remote_list_management

			;;

			*)
				__status $a
				__repaint conf "${file[confcl]}"
			;;

		esac

	done
}

function __menu_remote_list_management() {
	# Add or Remove new remote list providers

	__repaint conf "${file[confcl]}"
	
	while true; do

		printf "${bold}LIST MANAGEMENT: CUSTOM REMOTE SOURCES${normal}"
		printf "\n\nCustom remote list resources\n\n"
		
		# Display custom remote lists available for management
		# $listsc # Value discovered during list array auto declares (see above)

		let n=$listc+1
		while [ $n -le $listsc ] ; do
			status="${list[status${n}]}"
			info="${list[info${n}]}"
			printf "$n) [$status] - $info\n"
			let n=n+1
		done

		printf "\n${bold}A${normal}) to Add a custom remote hosts list provider\n"
		printf "${bold}D${normal}) to Delete a custom remote hosts list provider\n"
		printf "${bold}E${normal}) to Edit a custom remote hosts list provider\n"
		printf "\n0) Return to Main Menu\n"

		read a

		case $a in

			0)
				__menu_main
			;;

			[Aa])

				__clear

				printf "\nEnter details for new resource list ${n}.\n\n"
				
				__conf_update 'add' "list[status${n}]='+'" "${file[confcl]}"

				printf "Enter brief list description: "
				read a
				__conf_update 'add' "list[info${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the download URL e.g https://example.com/download-page.\nDo not include the package/file name or a trailing slash: "
				read a
				__conf_update 'add' "list[src${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package name: "
				read a
				__conf_update 'add' "list[file${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the package type e.g unzip, p7zip, direct or raw: "
				read a
				__conf_update 'add' "list[flag${n}]='${a}'" "${file[confcl]}"

				printf "\nEnter the target file name that contains the hosts data: "
				read a
				__conf_update 'add' "list[target${n}]='${a}'" "${file[confcl]}"

				printf "\nDo all hostnames in this list need an IP address prefix? (1 for Yes, 0 for No): "
				read a
				__conf_update 'add' "list[ip${n}]='${a}'" "${file[confcl]}"

				printf "\nList ${n} added to hosts file repository. $package will restart after you press Enter.\n"
				read a
				
				__repaint hard

			;;

			[Dd])

				printf "\nEnter list number to delete.\n"
				read a

				__conf_update 'remw' "${a}]" "${file[confcl]}"

				printf "\nList ${a} deleted from hosts file repository. $package will restart after you press Enter.\n"
				read a

				__repaint hard
				
			;;

			[Ee])
				# To be implemented
					__repaint hard
			;;

			*)

			;;

		esac

	done
}

function __menu_custom_list_management() {
	# Show and manage host lists
	
	__repaint conf "${file[confcl]}"
	
	while true; do
	
		if test $debug -ne '0' ; then
			tmux capture-pane -pJ -S - >> ${file[debug]}
		fi

		printf "${bold}CUSTOM LIST MANAGEMENT${normal}"
		printf "\n\nUpdate list status\n\n"

		# Display custom list options
		unset menu
		menu[1]="Add a host to custom whitelist"
		menu[2]="Add a host to custom wild whitelist"
		menu[3]="Add a host to custom blacklist\n"
		menu[4]="Remove a host from custom whitelist"
		menu[5]="Remove a host from custom wild whitelist"
		menu[6]="Remove a host from custom blacklist\n"
		menu[7]="Display custom whitelist"
		menu[8]="Display custom wild whitelist"
		menu[9]="Display custom blacklist"

		n=1
		for i in "${menu[@]}" ; do
			printf "$n) ${i}\n"
			let n=n+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter option number then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Add to custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a
				
				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			2) # Add to custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confwlw]}" # Add host to wild whitelist
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			3) # Add to custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				printf "Type in a host to add then press Enter. Press 0 to exit:\n\n"
				read a

				case $a in
					0)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
					
					*)
						__conf_update 'add' "$a" "${file[confbl]}"
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			4) # Remove from custom whitelist

				__remove_custom_list_entry_menu ${file[confwl]} "whitelist"

			;;

			5) # Remove from custom wild whitelist

				__remove_custom_list_entry_menu ${file[confwlw]} "wild whitelist"

			;;

			6) # Remove from custom blacklist

				__remove_custom_list_entry_menu ${file[confbl]} "blacklist"

			;;

			7) # Display custom whitelist

				printf "Custom whitelist is located at ${file[confwl]}\n\n"
				cat "${file[confwl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			8) # Display custom wild whitelist

				printf "Custom wild whitelist is located at ${file[confwlw]}\n\n"
				cat "${file[confwlw]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			9) # Display custom blacklist

				printf "Custom blacklist is located at ${file[confbl]}\n\n"
				cat "${file[confbl]}"
				printf "\n\nPress Enter to return to previous menu:"
				read a

				case $a in
					*)
						__repaint '__menu_custom_list_management' # Effectively 'Return here'
					;;
				esac

			;;

			*)


			;;

		esac

	done
}

function __menu_reset_confs() {

	__repaint conf "${file[confcl]}"

	while true; do

		printf "${bold}CUSTOM CONFS MANAGEMENT${normal}"
		printf "\n\nReset custom lists and configurations\n\n"

		# Display menu
		unset menu
		menu[1]="Reset general configurations to their default values"
		menu[2]="Delete custom host file repository lists"
		menu[3]="Delete custom whitelist"
		menu[4]="Delete custom whitelist wild"
		menu[5]="Delete custom blacklist"
		menu[6]="Delete log of removed hosts"
		menu[7]="Delete general log"
		menu[8]="Delete debug log"

		m=1
		while [ $m -le ${#menu[@]} ] ; do
			printf "$m) ${menu[$m]}\n"
			let m=m+1
		done
		
		printf "\n0) Return to Main Menu\n"
		
		printf "\nEnter item number to action then press Enter.\n"
		
		read a

		case $a in

			0)
				__menu_main
			;;

			1) # Reset confs[]
				__conf_delete "${file[conf]}" "$package custom configuration"

			;;

			2) # Delete custom host lists
				__conf_delete "${file[confcl]}" "Custom host file repositories"

			;;

			3) # Delete custom whitelist
				__conf_delete "${file[confwl]}" "custom whitelist"
			;;

			4) # Delete custom whitelist wild
				__conf_delete "${file[confwlw]}" "custom whitelist wild"

			;;

			5) # Delete custom blacklist
				__conf_delete "${file[confbl]}" "custom blacklist"

			;;

			6)
				__conf_delete "${file[confr]}" "removed hosts log"

			;;

			7)
				__conf_delete "${file[log]}" "removed hosts log"

			;;

			8)

			;;

			*)
				__repaint conf "${file[confcl]}"
			;;

		esac

	done

	__repaint conf "${file[confcl]}"

}

## Launch

function __launch() {
	# launch terminal

	terminal=( konsole gnome-terminal x-terminal-emulator xdg-terminal terminator urxvt rxvt Eterm aterm roxterm xfce4-terminal termite lxterminal xterm )
	for i in ${terminal[@]}; do
		if command -v $i > /dev/null 2>&1; then
			exec $i -e "$0"
			# break
		else
			printf "\nUnable to automatically determine the correct terminal program to run e.g Console or Konsole. Please run this $package from the command line.\n"
			read something
			exit 1
		fi
	done
}

## Debug Flags
# To be moved to __log() (see near top of file)
case "${debug}" in

	1)
		#exec 3>&1 4>&2
		#trap 'exec 2>&4 1>&3' 0 1 2 3
		#exec 2>&1 >> "${file[log]}"
		exec 2>> "${file[debug]}"
	;;
	
esac

## Boot
__run "$@" # Loops back to the start. The script is read by BASH then __run is run. This ensures all functions are read into memory before anything happens.

# Exit is at end of __run()

# FOR DEBUGGING

# declare -p
